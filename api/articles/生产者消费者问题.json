{"title":"生产者消费者问题","uid":"35e4bdf3cccf47af2799cbeef79306c1","slug":"生产者消费者问题","date":"2023-06-07T15:11:37.000Z","updated":"2023-06-08T05:17:50.242Z","comments":true,"path":"api/articles/生产者消费者问题.json","keywords":null,"cover":"https://img1.baidu.com/it/u=408399948,2507537664&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=817","content":"<h1 id=\"什么是生产者消费者问题？（引入）\"><a href=\"#什么是生产者消费者问题？（引入）\" class=\"headerlink\" title=\"什么是生产者消费者问题？（引入）\"></a>什么是生产者消费者问题？（引入）</h1><p>  系统中只有一组生产者和消费者，生产者每次生产一个产品放到缓冲区中，消费者进行每次对缓冲区取一个进程并使用，他们之间的关系就像<strong>大学宿舍带饭一样</strong>，你把钱给了室友，室友拿着你的钱给你买来了饭。那么传输介质<strong>钱</strong>就相当于缓冲区。</p>\n<p>  如果一元为最基本单位，如果你想买一个棒棒糖，那么最基本的一块钱就可以买到。所以你就可以给你室友一块钱来进行购买。</p>\n<p>  那么现在又有了一个新的问题，如果你想买的东西不是一块钱，你给你室友多少钱，你室友才能帮你买到饭，那么意思就是，你给的钱不够，室友不能帮你买到想要的饭，你给的钱太多，室友就赚了一部分钱（并不想发生），所以这里就需要设置合理的缓冲区。</p>\n<p>  上面的这个东西可以进行抽象为生产者和消费者的单缓冲问题和多缓冲问题，在单缓冲问题中（上述买棒棒糖），我们只需要给一个最基本单位就可以，所以缓冲区大小为1，那么在多缓冲区问题中，我们一个最基本单位肯定不足以去支撑，所以我们就需要进行一个缓冲区大小的合理选择。</p>\n<p>  只有缓冲区大小满了（<strong>这里假设合理即满</strong>），消费者才能去消费（室友才能去帮你买饭），那么我们需要做的事情就是放入到一块钱到盘子中，而室友需要做的是把一块钱从盘子中取出来，那么在我们放之前的动作，室友都是在进行等待我们往盘子中放入东西。</p>\n<h1 id=\"生产者消费者问题\"><a href=\"#生产者消费者问题\" class=\"headerlink\" title=\"生产者消费者问题\"></a>生产者消费者问题</h1><p>  生产者和消费者共享一个初始化为空，大小为n的缓冲区。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">缓冲区没满，生产者生产并放入缓冲区中，否则进行阻塞（缓冲区没满--&gt;生产者生产）\n缓冲区中不为空，消费者读取，否则进行等待。（缓冲区不为空--&gt;消费者消费）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"P、V操作\"><a href=\"#P、V操作\" class=\"headerlink\" title=\"P、V操作\"></a>P、V操作</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">P：缓冲区是否有空位，若有则空位-1，若无，则处于阻塞状态\nV：（空位+1）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n\n\n<p>这里的生产者消费者问题可以抽象到golang中进行进程间通信。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">这里有如下的问题，起两个进程，第一个进程输出0-10，第二个进程输出第一个进程输出数字的二倍。例如122436.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>那么的话，我们是否可以用生产者消费者问题中的单缓冲区来进行实现？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">思路：\n （1）创建一个缓冲区（盘子）\n （2）第一个线程输出后，把数字放到单缓冲区中，然后进行监听单缓冲区是否有数据输入\n （3）第二个线程一直监听单缓冲区，如果有数据输入，则进行读出，读出后进行*2操作\n （4）运算结束后，向单缓冲区中放入数据，代表线程2完成操作\n （5）线程1收到后，继续2-4过程，直到运算结束\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>golang的代码实现：</p>\n<p>这里可以把操作系统中的生产者消费者问题进行再抽象，例如P、V操作是检测缓冲区是否有空位。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Thread2这里起一个线程来进行读取线程中的数据，直到关闭管道。\nThread1这里就是输出一个数之后，向缓冲区中进行写入，Thread2拿到缓冲区数据后，然后执行计算，输出后，向缓冲区写入，然后再执行此操作\n这里抽象成如下的图<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230608110642158.png\" alt=\"image-20230608110642158\"></p>\n<p>如上图，其实就是一个简单的流程图，知道bufferchan不关闭就一直处于阻塞状态。</p>\n<h3 id=\"利用channel管道实现进程间通信\"><a href=\"#利用channel管道实现进程间通信\" class=\"headerlink\" title=\"利用channel管道实现进程间通信\"></a>利用channel管道实现进程间通信</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;sync&quot;\n)\n\nvar bufferchan &#x3D; make(chan int, 1)\nvar wg &#x3D; &amp;sync.WaitGroup&#123;&#125;\n\nfunc Thread1() &#123;\n\tdefer wg.Done()\n\tcount :&#x3D; 10\n\tfor i :&#x3D; 0; i &lt; count; i++ &#123;\n\t\tfmt.Printf(&quot;Thread 1 value: %v\\n&quot;, i)\n\t\tbufferchan &lt;- i\n\t\t&lt;-bufferchan\n\t&#125;\n\tclose(bufferchan)\n&#125;\nfunc Thread2() &#123;\n\tdefer wg.Done()\n\tfor &#123;\n\t\tselect &#123;\n\t\tcase value, ok :&#x3D; &lt;-bufferchan:\n\t\t\tif !ok &#123;\n\t\t\t\tgoto EXIT\n\t\t\t&#125; else &#123;\n\t\t\t\tfmt.Printf(&quot;Thread 2 value: %v\\n&quot;, value*2)\n\t\t\t\tbufferchan &lt;- 1\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\nEXIT:\n\tfmt.Println(&quot;done&quot;)\n&#125;\nfunc main() &#123;\n\twg.Add(2)\n\tgo Thread1()\n\tgo Thread2()\n\twg.Wait()\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"生产者消费者引出的进程间通信的问题\"><a href=\"#生产者消费者引出的进程间通信的问题\" class=\"headerlink\" title=\"生产者消费者引出的进程间通信的问题\"></a>生产者消费者引出的进程间通信的问题</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">在学习操作系统的时候肯定接触过生产者消费者引出的线程间通信导致的读多写少或者是读少写多的问题<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>  大家可以设想一下现在我们的内存里有一个ArrayList，这个ArrayList默认情况下肯定是线程不安全的，要是多个线程并发读和写这个ArrayList可能会有问题。</p>\n<h5 id=\"Golang代码实现操作系统-内存读写问题\"><a href=\"#Golang代码实现操作系统-内存读写问题\" class=\"headerlink\" title=\"Golang代码实现操作系统 内存读写问题\"></a>Golang代码实现操作系统 内存读写问题</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;sync&quot;\n)\n\nvar i &#x3D; 0\n\nvar wg &#x3D; &amp;sync.WaitGroup&#123;&#125;\nvar bufferchan &#x3D; make(chan int, 100)\n\nfunc Count(v int) &#123;\n\ti &#x3D; i + v\n&#125;\nfunc work(Thread int) &#123;\n\tdefer wg.Done()\n\tfor v :&#x3D; range bufferchan &#123;\n\t\tfmt.Printf(&quot;Thread: %v\\n&quot;, Thread)\n\t\tCount(v)\n\t&#125;\n&#125;\nfunc storeBuffer() &#123;\n\tdefer wg.Done()\n\tcount :&#x3D; 100\n\tfor g :&#x3D; 0; g &lt; count; g++ &#123;\n\t\tbufferchan &lt;- g\n\t&#125;\n\tclose(bufferchan)\n&#125;\n\nfunc main() &#123;\n\twg.Add(1)\n\tgo storeBuffer()\n\tfor worker :&#x3D; 0; worker &lt; 10; worker++ &#123;\n\t\twg.Add(1)\n\t\tgo work(worker)\n\t&#125;\n\twg.Wait()\n\tfmt.Printf(&quot;i: %v\\n&quot;, i)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230608112905395.png\" alt=\"image-20230608112905395\"></p>\n<h5 id=\"golang协程读写问题的解决方式\"><a href=\"#golang协程读写问题的解决方式\" class=\"headerlink\" title=\"golang协程读写问题的解决方式\"></a>golang协程读写问题的解决方式</h5><h6 id=\"（1）加锁\"><a href=\"#（1）加锁\" class=\"headerlink\" title=\"（1）加锁\"></a>（1）加锁</h6><p>  这里的两个值是不一样就是因为脏写的原因，如果要让他们变得一样，那么就得需要操作系统中学到的加锁来实现。即该操作，只能让一个协程来进行，其他协程均处于阻塞状态。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var m &#x3D; &amp;sync.Mutex&#123;&#125;\nfunc Count(v int) &#123;\n\tm.Lock() &#x2F;&#x2F;枷锁\n\ti &#x3D; i + v\n\tm.Unlock()\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h6 id=\"（2）用channel管道\"><a href=\"#（2）用channel管道\" class=\"headerlink\" title=\"（2）用channel管道\"></a>（2）用channel管道</h6><p>  那么加锁可以实现的话，是否也可以用管道来进行实现阻塞呢，我们可以定义一个单缓冲管道flagchan。也可以用来进行实现</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var flagchan &#x3D; make(chan bool, 1)\nfunc Count(v int) &#123;\n\tflagchan &lt;- true\n\ti &#x3D; i + v\n\t&lt;-flagchan\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","feature":true,"text":"什么是生产者消费者问题？（引入） 系统中只有一组生产者和消费者，生产者每次生产一个产品放到缓冲区中，消费者进行每次对缓冲区取一个进程并使用，他们之间的关系就像大学宿舍带饭一样，你把钱给了室友，室友拿着你的钱给你买来了饭。那么传输介质钱就相当于缓冲区。 如果一元为最基本单位，如果你...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":2,"path":"api/tags/开发.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%88%E5%BC%95%E5%85%A5%EF%BC%89\"><span class=\"toc-text\">什么是生产者消费者问题？（引入）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">生产者消费者问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#P%E3%80%81V%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">P、V操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8channel%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">利用channel管道实现进程间通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E5%BC%95%E5%87%BA%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">生产者消费者引出的进程间通信的问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Golang%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">Golang代码实现操作系统 内存读写问题</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#golang%E5%8D%8F%E7%A8%8B%E8%AF%BB%E5%86%99%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">golang协程读写问题的解决方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E5%8A%A0%E9%94%81\"><span class=\"toc-text\">（1）加锁</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E7%94%A8channel%E7%AE%A1%E9%81%93\"><span class=\"toc-text\">（2）用channel管道</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"海康威视iVMS综合安防系统任意文件上传漏洞复现","uid":"ffd34013f8786614e92c482797ac49f0","slug":"海康威视iVMS综合安防系统任意文件上传漏洞复现","date":"2023-05-31T00:13:55.000Z","updated":"2023-05-31T00:15:54.796Z","comments":true,"path":"api/articles/海康威视iVMS综合安防系统任意文件上传漏洞复现.json","keywords":null,"cover":null,"text":"海康威视ivms综合安防系统影响范围海康威视综合安防系统iVMS-5000 海康威视综合安防系统 iVMS-8700 指纹&#x2F;views&#x2F;home&#x2F;file&#x2F;installPackage.rar 检测脚本 ","link":"","photos":[],"count_time":{"symbolsCount":125,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","count":1,"path":"api/tags/漏洞复现.json"}],"author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"feature":true}}