{"title":"字节序列问题","uid":"67ca9e91ec24db55ca87af66a3ba205d","slug":"字节序列问题","date":"2023-06-19T02:20:29.000Z","updated":"2023-06-23T07:47:41.984Z","comments":true,"path":"api/articles/字节序列问题.json","keywords":null,"cover":null,"content":"<h1 id=\"字节序的问题\"><a href=\"#字节序的问题\" class=\"headerlink\" title=\"字节序的问题\"></a>字节序的问题</h1><p>上次在<strong>内网穿透</strong>已经提到，字节序分为大端和小端，由于不同的芯片造成了不同的字节序列，例如X86是小端存储，System&#x2F;370，SPARC是大端存储，ARM是可以配置的。</p>\n<h3 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h3><p>不同地区和不同地区的人之间是存在方言的，同一地区由于方言相同，就可以完全通信，但是如果要不同地区之间的人进行通信，由于方言不同，导致你听不懂我的，我听不懂你的，就导致了一系列的问题。所以的话，普通话就出现了，普通话的出现就解决了不同地区之间的沟通问题，那么网络字节序列和主机字节序列也是如此。</p>\n<h3 id=\"网络字节序列和主机字节序列\"><a href=\"#网络字节序列和主机字节序列\" class=\"headerlink\" title=\"网络字节序列和主机字节序列\"></a>网络字节序列和主机字节序列</h3><p>前面的大端和小端都是在说计算机本身，称为主机字节序列，是自己电脑上的问题，如果自己给自己发送，当然没有任何问题，那么如果在网络中进行发送和读取，如果发送方和你的字节序列是不一致的，那么读取到的内容也会出现问题，所以在网络发送过程中，TCP&#x2F;IP规定，必须使用大端序列来进行发送。（也就是计算机和计算机之间说普通话），接受到数据之后，再转换为自己的字节序列来进行存储，完全可以实现通信。但是需要自定义大小端的来进行发送。</p>\n<h1 id=\"tcp粘包问题\"><a href=\"#tcp粘包问题\" class=\"headerlink\" title=\"tcp粘包问题\"></a>tcp粘包问题</h1><h3 id=\"造成的原因：\"><a href=\"#造成的原因：\" class=\"headerlink\" title=\"造成的原因：\"></a>造成的原因：</h3><p><strong>tcp是流传输</strong>，默认采用nagle算法，合并较小的数据包，再发送。所以数据发送出来的时候就已经是粘包状态。但是接收方并不知道发送方合并数据包，而且数据包在TCP中是没有分界的，所以就导致了粘包问题。</p>\n<h3 id=\"解决粘包问题：\"><a href=\"#解决粘包问题：\" class=\"headerlink\" title=\"解决粘包问题：\"></a>解决粘包问题：</h3><h4 id=\"网络编程中的TLV规范\"><a href=\"#网络编程中的TLV规范\" class=\"headerlink\" title=\"网络编程中的TLV规范\"></a>网络编程中的TLV规范</h4><p>TLV是通信协议的一种约束。例如TCP、UDP都是通信协议，但是上述的协议是不可以改变的，但是在处理实际的业务的过程中，我们的端到端通信的数据是不确定的，我们希望自定义通信协议然后到对方进行解析。TLV便是一种用户自定义的通信协议。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">数据的类型Tag（T）\t                     2字节 or 4字节\n数据的长度Length（L）\t                 2字节 or 4字节\n数据的值Value（V）\t                    由length指定<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>如下图。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> +----+-----+---------+\n|type| len | content |\n+----+---------------+\n| 4  |  4  |   ...   |\n+----+---------------+<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"字节序列问题\"><a href=\"#字节序列问题\" class=\"headerlink\" title=\"字节序列问题\"></a>字节序列问题</h4><p>双方在自定义协议的时候需要统一<strong>数据格式</strong>和<strong>大小端</strong></p>\n","feature":true,"text":"字节序的问题上次在内网穿透已经提到，字节序分为大端和小端，由于不同的芯片造成了不同的字节序列，例如X86是小端存储，System&#x2F;370，SPARC是大端存储，ARM是可以配置的。 引入不同地区和不同地区的人之间是存在方言的，同一地区由于方言相同，就可以完全通信，但是如...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":3,"path":"api/tags/开发.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%97%E8%8A%82%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">字节序的问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">引入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">网络字节序列和主机字节序列</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">tcp粘包问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%A0%E6%88%90%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A\"><span class=\"toc-text\">造成的原因：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">解决粘包问题：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84TLV%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">网络编程中的TLV规范</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">字节序列问题</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"内网穿透","uid":"6f6e74f284af1d44cd531a6b40059037","slug":"内网穿透","date":"2023-06-13T03:17:59.000Z","updated":"2023-08-15T13:23:47.679Z","comments":true,"path":"api/articles/内网穿透.json","keywords":null,"cover":[],"text":"内网穿透在内网渗透的过程中，内网穿透是相当重要的，可以把内网中的流量代理出来，也可以把内网的某个端口映射出来，那么今天就先讲解一下内网穿透的具体原理。 内网穿透（端口映射）的原理引入在内网穿透过程中，通常你在服务器端 监听服务器端口，然后客户端连接内网机器连接服务器的某个端口，你...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","count":5,"path":"api/tags/内网渗透.json"}],"author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"feature":true}}