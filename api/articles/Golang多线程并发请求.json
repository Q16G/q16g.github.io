{"title":"Golang多线程并发学习","uid":"a52b5fed34208f47aa981d461e5d2476","slug":"Golang多线程并发请求","date":"2023-05-25T12:44:51.000Z","updated":"2023-05-26T07:59:18.484Z","comments":true,"path":"api/articles/Golang多线程并发请求.json","keywords":null,"cover":null,"content":"<h1 id=\"golang多线程并发问题\"><a href=\"#golang多线程并发问题\" class=\"headerlink\" title=\"golang多线程并发问题\"></a>golang多线程并发问题</h1><p>  在这几天写golang的多线程并发中，遇到了两个问题，第一个是并发个数控制，第二个是当进行高并发http请求的时候，导致连接池爆满而无法进行正常的请求。这里遂做一个记录，顺便对golang的http请求库、正则库做一个详细介绍。</p>\n<h1 id=\"net-x2F-HTTP\"><a href=\"#net-x2F-HTTP\" class=\"headerlink\" title=\"net&#x2F;HTTP\"></a>net&#x2F;HTTP</h1><p>http请求库有两种请求方式，直接请求和定义client来进行请求，这里本人喜欢定义client来进行请求，因为client中可以自定义很多东西，这里就记录一种定义client的请求方式。定义client来请求一般有几个步骤</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">（1）定义transport\n（2）定义client并且把transport写入\n（3）newrequest出来，如果是POST请求设置Content-Type\n（3）用client.do来进行触发http请求<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>详解http.transport数据结构：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">idleMu：空闲连接锁\ncloseIdle：是否关闭所有空闲连接的标志\nidleConn：最近使用的空闲连接\nidleConnWait：等待空闲连接的队列\nidleLRU：连接的LRU算法\nreqMu：请求的互斥锁\nreqCanceler：取消请求的函数\naltMu：备用协议的锁\naltProto：备用协议的值，可以为nil或者map[string]RoundTripper，键为URI scheme\nconnsPerHostMu：单个主机内连接数的锁\nconnsPerHost：单个主机内的连接数\nconnsPerHostWait：等待单个主机内连接的队列\nProxy：返回给定请求的代理的函数\nOnProxyConnectResponse：处理代理的CONNECT请求响应的函数\nDialContext：用于创建非加密TCP连接的拨号函数\nDial：创建非加密TCP连接的拨号函数\nDialTLSContext：用于创建非代理HTTPS请求的TLS连接的可选拨号函数\nDialTLS：用于创建非代理HTTPS请求的TLS连接的可选拨号函数\nTLSClientConfig：TLS配置，用于tls.Client\nTLSHandshakeTimeout：TLS握手的最长等待时间\nDisableKeepAlives：是否禁止HTTP keep-alive和仅用于单个HTTP请求的连接\nDisableCompression：是否禁止在请求中使用gzip编码压缩\nMaxIdleConns：所有主机中空闲（keep-alive）连接的最大数量\nMaxIdleConnsPerHost：每个主机中保留的最大空闲（keep-alive）连接数，如果为零则使用默认值\nMaxConnsPerHost：每个主机中最多允许的连接数\nIdleConnTimeout：空闲（keep-alive）连接的最长空闲时间\nResponseHeaderTimeout：发送请求后等待服务器响应头的最长时间\nExpectContinueTimeout：如果请求包含“Expect: 100-continue”标头，则等待服务器第一个响应头的最长时间\nTLSNextProto：指定Transport在TLS ALPN协议协商后如何切换到备用协议的函数\nProxyConnectHeader：发送到代理服务器的headers\nGetProxyConnectHeader：返回发送到代理服务器的headers的函数\nMaxResponseHeaderBytes：限制服务器响应头的字节数\nWriteBufferSize：写缓冲区的大小\nReadBufferSize：读缓冲区的大小\nnextProtoOnce：TLSNextProto和h2transport（通过onceSetNextProtoDefaults初始化）的初始化锁\nh2transport：HTTP&#x2F;2传输层\ntlsNextProtoWasNil：nextProtoOnce函数是否被调用过<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中我用到了transport中的两个</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">DisableKeepAlives：禁止长连接，避免出现了因为连接不释放而导致连接池爆满的问题\nTLSClientConfig：其中用到了config中的InsecureSkipVerify，这里的意思就是不做https的证书校验，使得访问http和https是相同的<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"GET请求：\"><a href=\"#GET请求：\" class=\"headerlink\" title=\"GET请求：\"></a>GET请求：</h3><p>这里做一个简单的进行GET请求POST请求的发包：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n\t&quot;crypto&#x2F;tls&quot;\n\t&quot;fmt&quot;\n\t&quot;io&quot;\n\t&quot;net&#x2F;http&quot;\n\t&quot;time&quot;\n)\n\nfunc main() &#123;\n\tTransport :&#x3D; &amp;http.Transport&#123;\n\t\tTLSClientConfig:   &amp;tls.Config&#123;InsecureSkipVerify: true&#125;,\n\t\tDisableKeepAlives: true,\n\t&#125;\n\tClient :&#x3D; &amp;http.Client&#123;\n\t\tTransport: Transport,\n\t\tTimeout:   time.Duration(time.Second * 3),\n\t&#125;\n\trequests, err :&#x3D; http.NewRequest(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;baidu.com&#x2F;&quot;, nil)\n\trequests.Header.Set(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;535.1 (KHTML, like Gecko) Chrome&#x2F;14.0.835.163 Safari&#x2F;535.1&quot;)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;err: %v\\n&quot;, err)\n\t\treturn\n\t&#125;\n\tr, err2 :&#x3D; Client.Do(requests)\n\tif err2 !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;err2: %v\\n&quot;, err2)\n\t\treturn\n\t&#125;\n\tdefer r.Body.Close()\n\tb, err3 :&#x3D; io.ReadAll(r.Body)\n\tif err3 !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;err3: %v\\n&quot;, err3)\n\t\treturn\n\t&#125;\n\tfmt.Printf(&quot;string(b): %v\\n&quot;, string(b))\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"POST请求：\"><a href=\"#POST请求：\" class=\"headerlink\" title=\"POST请求：\"></a>POST请求：</h3><p>针对POST请求就有几种说法</p>\n<p>（1）传递的是json  –&gt; Content-Type用json形式 –&gt; 传递数据使用byte流进行封装</p>\n<p>（2）传递的是普通 –&gt; Content-Type使用普通形式 –&gt; 传递数据使用string流进行封装</p>\n","feature":true,"text":"golang多线程并发问题 在这几天写golang的多线程并发中，遇到了两个问题，第一个是并发个数控制，第二个是当进行高并发http请求的时候，导致连接池爆满而无法进行正常的请求。这里遂做一个记录，顺便对golang的http请求库、正则库做一个详细介绍。 net&#x2F;HT...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":1,"path":"api/tags/开发.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#golang%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">golang多线程并发问题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#net-x2F-HTTP\"><span class=\"toc-text\">net&#x2F;HTTP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GET%E8%AF%B7%E6%B1%82%EF%BC%9A\"><span class=\"toc-text\">GET请求：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#POST%E8%AF%B7%E6%B1%82%EF%BC%9A\"><span class=\"toc-text\">POST请求：</span></a></li></ol></li></ol></li></ol>","author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"关于nps工具的魔改","uid":"badd5d9a02640c51cb699c12c4298740","slug":"关于nps工具的魔改","date":"2023-05-26T07:52:53.000Z","updated":"2023-05-26T07:56:34.404Z","comments":true,"path":"api/articles/关于nps工具的魔改.json","keywords":null,"cover":"https://k.sinaimg.cn/n/sinacn10110/470/w1170h900/20190411/7c33-hvntnkq4891892.jpg/w700d1q75cms.jpg","text":"免责声明🧐本工具仅面向 合法授权 的企业安全建设行为，如您需要测试本工具的可用性，请自行搭建靶机环境。 在使用本工具进行检测时，您应确保该行为符合当地的法律法规，并且已经取得了足够的授权。请勿对非授权目标进行扫描。 如您在使用本工具的过程中存在任何非法行为，您需自行承担相应后果，...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"工具魔改","slug":"工具魔改","count":1,"path":"api/tags/工具魔改.json"}],"author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"NTLM-Relay攻击","uid":"87b274fadad0a6b05fd4814550be9f11","slug":"NTLM-Relay攻击","date":"2023-05-24T04:12:28.000Z","updated":"2023-05-25T08:06:43.763Z","comments":true,"path":"api/articles/NTLM-Relay攻击.json","keywords":null,"cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201505%2F31%2F20150531134332_s4dxn.thumb.700_0.jpeg&refer=http%3A%2F%2Fb-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1687593990&t=c2298c6d35596afce3b266d2ab766151","text":"前言介绍 NTLM认证分为本地认证和网络认证，当我们开机登陆用户账号的时候，就需要将lsass中的密码转换为明文hash与sam文件中进行对比，这种方式就是本地认证。 而当我们访问局域网中的一台主机的SMB共享的时候，需要提供凭证才能进行访问，这个过程就是网络认证。 NTLM协议...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","count":2,"path":"api/tags/内网渗透.json"}],"author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"feature":true}}