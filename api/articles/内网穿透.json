{"title":"内网穿透","uid":"6f6e74f284af1d44cd531a6b40059037","slug":"内网穿透","date":"2023-06-13T03:17:59.000Z","updated":"2023-06-14T09:10:22.613Z","comments":true,"path":"api/articles/内网穿透.json","keywords":null,"cover":[],"content":"<h1 id=\"内网穿透\"><a href=\"#内网穿透\" class=\"headerlink\" title=\"内网穿透\"></a>内网穿透</h1><p>在内网渗透的过程中，内网穿透是相当重要的，可以把内网中的流量代理出来，也可以把内网的某个端口映射出来，那么今天就先讲解一下内网穿透的具体原理。</p>\n<h2 id=\"内网穿透（端口映射）的原理引入\"><a href=\"#内网穿透（端口映射）的原理引入\" class=\"headerlink\" title=\"内网穿透（端口映射）的原理引入\"></a>内网穿透（端口映射）的原理引入</h2><p>在内网穿透过程中，通常你在服务器端 监听服务器端口，然后客户端连接内网机器连接服务器的某个端口，你在访问服务器的映射端口就能访问，如下图。</p>\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230613112426156.png\" alt=\"image-20230613112426156\"></p>\n<p>那么他们到底是如何进行了端口之间的映射转换，肉鸡的端口如何来进行连接，到底经过了内部什么转换，仅限于使用者的话，是不能得知的。</p>\n<h2 id=\"端口映射的原理介绍\"><a href=\"#端口映射的原理介绍\" class=\"headerlink\" title=\"端口映射的原理介绍\"></a>端口映射的原理介绍</h2><p>在端口映射过程中，通常是这样的。如下图</p>\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230613114612333.png\" alt=\"image-20230613114612333\"></p>\n<p>整个流程是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">（1）内网客户端连接8088端口，8088端口“告诉”9998端口你需要开始监听，让人连接，这里9998端口开始监听\n（2）内网客户端再连接9998端口，9998端口负责将9999端口监听到的内容发送到内网客户端（中继的作用）\n（3）客户（右下客户端）连接9999端口，负责进行请求<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>各个部分的作用</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">（1）服务端的8088端口： 负责进行内网的通信，检测客户端是否存活\n（2）服务端的9998端口：负责用户和内网之间的传递<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"端口映射代码编写过程中的一些问题\"><a href=\"#端口映射代码编写过程中的一些问题\" class=\"headerlink\" title=\"端口映射代码编写过程中的一些问题\"></a>端口映射代码编写过程中的一些问题</h3><h4 id=\"大端存储和小端存储\"><a href=\"#大端存储和小端存储\" class=\"headerlink\" title=\"大端存储和小端存储\"></a>大端存储和小端存储</h4><p>不同的PC之间是用着可能不同的存储方式，这里需要理解大端存储和小端存储之前就需要先了解高地址和低地址、数据的高位和低位。</p>\n<h5 id=\"数据的高位和低位\"><a href=\"#数据的高位和低位\" class=\"headerlink\" title=\"数据的高位和低位\"></a>数据的高位和低位</h5><p>数据的高位就是左边的数、数据的低位就是右边的数。数据的高位和低位又称为高字节和低字节。</p>\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230613130614989.png\" alt=\"image-20230613130614989\"></p>\n<p>如上图，1就相对于4是高位，4就相对于1时低位。</p>\n<h5 id=\"高地址和低地址\"><a href=\"#高地址和低地址\" class=\"headerlink\" title=\"高地址和低地址\"></a>高地址和低地址</h5><p>为了便于管理存储地址，需要给地址进行编号，值较大的是高地址，值较小的是低地址。通常拿16进制来表示地址，0X00是低地址、0XFF是高地址。</p>\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230613132307258.png\" alt=\"image-20230613132307258\"></p>\n<h5 id=\"大端存储和小端存储-1\"><a href=\"#大端存储和小端存储-1\" class=\"headerlink\" title=\"大端存储和小端存储\"></a>大端存储和小端存储</h5><p>大端存储：是将数据的低位字节放在高地址处，高位字节放到低地址。</p>\n<p>小端存储：是将数据的高位字节放在高地址，低位字节放在低地址。</p>\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230613132457236.png\" alt=\"image-20230613132457236\"></p>\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230613132502550.png\" alt=\"image-20230613132502550\"></p>\n<h4 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h4><p>而内网穿透和其他的C&#x2F;S模式的服务器，因为不知道C和S具体是什么存储方式，所以在进行数据传递的时候，需要进行指定存储方式来进行读取或者传输。 这里又称为序列化和反序列化的过程。将二进制数据转换为数据类型就叫反序列化，将数据转换为二进制就称为序列化。</p>\n<p>这里需要知道一个前提：0x01020304 &lt;&#x3D;&#x3D;&gt; []byte{0x01, 0x02, 0x03, 0x04}</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">（1）在TCP&#x2F;IP协议规定，网络数据应采用大端字节序来进行传输\n（2）不管这台主机是大端机还是小端机，都会按照这个TCP&#x2F;IP规定的网络字节序来进行发送或者接受数据\n（3）如果当前主机是大端序，就需要先转换为大端序来，否则就忽略。直接发送即可。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h1 id=\"传输过程中的常见基础知识\"><a href=\"#传输过程中的常见基础知识\" class=\"headerlink\" title=\"传输过程中的常见基础知识\"></a>传输过程中的常见基础知识</h1><h2 id=\"字节（byte）和比特（bit）的介绍\"><a href=\"#字节（byte）和比特（bit）的介绍\" class=\"headerlink\" title=\"字节（byte）和比特（bit）的介绍\"></a>字节（byte）和比特（bit）的介绍</h2><p>比特（bit）是二进制位的简称，一个二进制（0&#x2F;1）就是一个bit，bit在计算机内部存储过程中是最小的存储单元。</p>\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230613222130171.png\" alt=\"image-20230613222130171\"></p>\n<p>字节Byte是计算机处理的最小的单位，习惯使用大写B来进行表示。每个字节有8个二进制位，所以字节和bit之间的转换关系是</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">字节于bit之间的转换关系： 1字节&#x3D;8bit<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h5 id=\"数据在网络传递过程中数据的规定：\"><a href=\"#数据在网络传递过程中数据的规定：\" class=\"headerlink\" title=\"数据在网络传递过程中数据的规定：\"></a>数据在网络传递过程中数据的规定：</h5><p>这里介绍一种不同网络之间数据传输的协议。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> +----+-----+---------+\n|type| len | content |\n+----+---------------+\n| 4  |  4  |   ...   |\n+----+---------------+<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里进行了传输过程中数据传输的规范，第一个是数据类型，第二个是数据长度，以后就是传输过程中的内容。通常来说，在golang的代码编写中，我们如果按照如上的规则来编写的话，我们可以按照如上来进行读取。</p>\n<p>这里个人思路：</p>\n<p>这里在数据传输过程中，不能每个中都有Type，如果有Type要读出来，如果没有Type，要直接进行数据的读取（这里根据实际情况来进行操作）</p>\n","feature":true,"text":"内网穿透在内网渗透的过程中，内网穿透是相当重要的，可以把内网中的流量代理出来，也可以把内网的某个端口映射出来，那么今天就先讲解一下内网穿透的具体原理。 内网穿透（端口映射）的原理引入在内网穿透过程中，通常你在服务器端 监听服务器端口，然后客户端连接内网机器连接服务器的某个端口，你...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"内网","slug":"内网","count":1,"path":"api/tags/内网.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F\"><span class=\"toc-text\">内网穿透</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%EF%BC%88%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%EF%BC%89%E7%9A%84%E5%8E%9F%E7%90%86%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">内网穿透（端口映射）的原理引入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">端口映射的原理介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">端口映射代码编写过程中的一些问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E7%AB%AF%E5%AD%98%E5%82%A8%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">大端存储和小端存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%9A%84%E9%AB%98%E4%BD%8D%E5%92%8C%E4%BD%8E%E4%BD%8D\"><span class=\"toc-text\">数据的高位和低位</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%AB%98%E5%9C%B0%E5%9D%80%E5%92%8C%E4%BD%8E%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">高地址和低地址</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E7%AB%AF%E5%AD%98%E5%82%A8%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8-1\"><span class=\"toc-text\">大端存储和小端存储</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E%EF%BC%9A\"><span class=\"toc-text\">说明：</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">传输过程中的常见基础知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E8%8A%82%EF%BC%88byte%EF%BC%89%E5%92%8C%E6%AF%94%E7%89%B9%EF%BC%88bit%EF%BC%89%E7%9A%84%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">字节（byte）和比特（bit）的介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%84%E5%AE%9A%EF%BC%9A\"><span class=\"toc-text\">数据在网络传递过程中数据的规定：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"设计模型","uid":"1208573faa087b8bddb01ba640107299","slug":"设计模型","date":"2023-06-12T07:24:39.000Z","updated":"2023-06-12T11:34:04.001Z","comments":true,"path":"api/articles/设计模型.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3406119999,3272762192&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500","text":"设计模式设计模式主要为提高代码的可读性、提高代码复用程度来进行的。 23种设计模式设计模式的设计理念这里的设计模式设计理念很多，比如开闭原则、单一职责原则、依赖倒转原则、合成复用原则等。这里基于几个重要的原则来进行详细的说明。 开闭原则简单来说就是一个功能点的实现不是靠修改代码来...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":2,"path":"api/tags/开发.json"}],"author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"feature":true}}