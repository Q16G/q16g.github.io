{"title":"设计模型","uid":"1208573faa087b8bddb01ba640107299","slug":"设计模型","date":"2023-06-12T07:24:39.000Z","updated":"2023-06-12T11:33:43.480Z","comments":true,"path":"api/articles/设计模型.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3406119999,3272762192&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500","content":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>设计模式主要为提高代码的可读性、提高代码复用程度来进行的。</p>\n<h1 id=\"23种设计模式\"><a href=\"#23种设计模式\" class=\"headerlink\" title=\"23种设计模式\"></a>23种设计模式</h1><h3 id=\"设计模式的设计理念\"><a href=\"#设计模式的设计理念\" class=\"headerlink\" title=\"设计模式的设计理念\"></a>设计模式的设计理念</h3><p>这里的设计模式设计理念很多，比如开闭原则、单一职责原则、依赖倒转原则、合成复用原则等。这里基于几个重要的原则来进行详细的说明。</p>\n<h5 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h5><p>简单来说就是一个功能点的实现不是靠修改代码来实现的，而是靠增加代码来实现的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">个人理解：\n   简单来说就是设计出来代码之后，如果要增加代码，尽量不修改原来的代码，而是在原来的代码上增加代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h6 id=\"开闭原则理解：\"><a href=\"#开闭原则理解：\" class=\"headerlink\" title=\"开闭原则理解：\"></a>开闭原则理解：</h6><p>假设这里有一个demo，定义了一个Banker类，进行了Save、Transform、Pay的三种方法</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Banker <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">*</span>Banker<span class=\"token punctuation\">)</span> <span class=\"token function\">Save</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"进行了存款业务\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">*</span>Banker<span class=\"token punctuation\">)</span> <span class=\"token function\">Transform</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"进行了转账业务\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">*</span>Banker<span class=\"token punctuation\">)</span> <span class=\"token function\">Pay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"进行了支付业务\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果要给Banker增加一个方法，那么我们应该如何去做呢？？？</p>\n<p>如果在上面的代码中增加一个股票的业务，这里我们可以直接写入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func (b *Banker) Shares() &#123;\n\tfmt.Println(&quot;进行了股票业务&quot;)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这里的业务是较为简单的，如果业务较为复杂，你修改原有的类，就显得较为困难，那么我们应该去正确的编写代码呢？？？？</p>\n<p>这里官方给出的解决方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">我们可以把Banker进行抽象，编写一个抽象的Banker，然后进行分类，我们可以继承并且实现抽象的Banker后进行Save方法\n\n有点类似于，Banker进行了细节划分，如下图，细化分为了SaveBanker、PayBanker、TransformBanker<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230612155500430.png\" alt=\"image-20230612155500430\"></p>\n<h6 id=\"官方代码实现如下：\"><a href=\"#官方代码实现如下：\" class=\"headerlink\" title=\"官方代码实现如下：\"></a>官方代码实现如下：</h6><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token comment\">/*\n这里定义了一个抽象的Banker接口，定义了DoSomeThing的方法\n*/</span>\n<span class=\"token keyword\">type</span> AbstractBanker <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">DoSomeThing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">/*\n这里实现了抽象Banker接口，并且做了自己的事情\n*/</span>\n<span class=\"token keyword\">type</span> SaveAbstractBanker <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>SB <span class=\"token operator\">*</span>SaveAbstractBanker<span class=\"token punctuation\">)</span> <span class=\"token function\">DoSomeThing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Save running....\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token operator\">...</span><span class=\"token punctuation\">.</span>\n<span class=\"token operator\">...</span><span class=\"token punctuation\">.</span>\n<span class=\"token operator\">...</span><span class=\"token punctuation\">.</span>\n<span class=\"token operator\">...</span><span class=\"token punctuation\">.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h6 id=\"官方代码实现的一些弊端：\"><a href=\"#官方代码实现的一些弊端：\" class=\"headerlink\" title=\"官方代码实现的一些弊端：\"></a>官方代码实现的一些弊端：</h6><p>  开闭原则如果用官方实现的话，我们就会发现一些问题</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">（1）如果各个Banker需要做的事情不同（这里指的是Save和Pay）中的方法中的形参不同，就会导致interface接口中定义很多类方法，如果面向抽象接口来进行编程的话，要实现多态就会较为复杂。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h6 id=\"个人想法：\"><a href=\"#个人想法：\" class=\"headerlink\" title=\"个人想法：\"></a>个人想法：</h6><p>我们既然可以用接口来完成，那么我们也可以用“类”来进行完成。我们可以定义一个基类BaseBanker，然后实现基类必须实现的方法，然后去子类去实现基类，自定义方法去实现。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> BaseBanker <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token comment\">/*\n\t\t属性1\n\t\t....\n\t*/</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>bb <span class=\"token operator\">*</span>BaseBanker<span class=\"token punctuation\">)</span> <span class=\"token function\">Pay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"进行一个支付业务\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">/*\n下面的SaveBanker继承了BaseBanker 并且有自己的Save方法\n*/</span>\n<span class=\"token keyword\">type</span> SaveBanker <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span>\n\tBaseBanker\n\t<span class=\"token comment\">/*\n\t\tSaveBanker自定义的一些属性\n\t*/</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>SB <span class=\"token operator\">*</span>SaveBanker<span class=\"token punctuation\">)</span> <span class=\"token function\">Save</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"进行了一个存储业务\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h6 id=\"个人想法的一些缺点和适用情况\"><a href=\"#个人想法的一些缺点和适用情况\" class=\"headerlink\" title=\"个人想法的一些缺点和适用情况\"></a>个人想法的一些缺点和适用情况</h6><pre class=\"line-numbers language-none\"><code class=\"language-none\">（1）不符合面向接口编程\n（2）如果类太多，就会导致继承比较复杂\n\n\n适用情况：\n   各个类之间的函数参数不定，如果使用接口实现较为复杂<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>这里个人还是建议，能面向接口编程，一定要面向接口编程。</strong></p>\n<h5 id=\"依赖倒转原则\"><a href=\"#依赖倒转原则\" class=\"headerlink\" title=\"依赖倒转原则\"></a>依赖倒转原则</h5><p>编写代码时，要依赖于接口，不要依赖于具体的实现，<strong>面向接口编程</strong> 给代码分层，接口层，实现层，逻辑层。</p>\n<p>例如，有以下的几种情况。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">（1）张三开宝马，如何编写代码\n（2）李四开奔驰，如何编写代码\n（3）张三开奥迪或者其他车，李四开奥迪或者其他车，又应该如何编写<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>我们可以去定义两个接口，一个person接口，一个car接口</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Car <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">type</span> Person <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">Drive</span><span class=\"token punctuation\">(</span>car Car<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>之后的话，我们可以实现这两个接口</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Zhangsan <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>zs <span class=\"token operator\">*</span>Zhangsan<span class=\"token punctuation\">)</span> <span class=\"token function\">Drive</span><span class=\"token punctuation\">(</span>car Car<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tcar<span class=\"token punctuation\">.</span><span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">type</span> Benchi <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>bc <span class=\"token operator\">*</span>Benchi<span class=\"token punctuation\">)</span> <span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"奔驰.....\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后我们就可以用代码来进行逻辑上的操作。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">var</span> a Person <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>Zhangsan<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n\ta<span class=\"token punctuation\">.</span><span class=\"token function\">Drive</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>Benchi<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230612164533989.png\" alt=\"image-20230612164533989\"></p>\n<h5 id=\"合成复用原则：\"><a href=\"#合成复用原则：\" class=\"headerlink\" title=\"合成复用原则：\"></a>合成复用原则：</h5><p>当我们用继承和组合都可以解决问题的时候，优先使用组合的方式来解决。 （因为：当我们使用继承的方式去解决的时候，如果父类中的某个方法要改变，子类也会受到影响，除非重写父类方法）</p>\n<h6 id=\"详细说明组合：\"><a href=\"#详细说明组合：\" class=\"headerlink\" title=\"详细说明组合：\"></a>详细说明组合：</h6><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> catc <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span>\n\tcat <span class=\"token operator\">*</span>cat\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>cc <span class=\"token operator\">*</span>catc<span class=\"token punctuation\">)</span> <span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tcc<span class=\"token punctuation\">.</span>cat<span class=\"token punctuation\">.</span><span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上的代码就是采用组合的方式而非继承的关系。</p>\n<h2 id=\"工厂三兄弟s\"><a href=\"#工厂三兄弟s\" class=\"headerlink\" title=\"工厂三兄弟s\"></a>工厂三兄弟s</h2><h3 id=\"工厂模式的介绍\"><a href=\"#工厂模式的介绍\" class=\"headerlink\" title=\"工厂模式的介绍\"></a>工厂模式的介绍</h3><p>如果业务层直接和基础类模块进行交互的话，那么就违背了单一职责原则，一个类即需要进行类的本身操作又需要进行实例化。所以我们在业务层和基础类模块之间增加了一层 工厂，业务层不必关心基础模块的具体实现，只需要和工厂进行交互即可，工厂负责基础模块的创建和其他繁杂的逻辑。</p>\n<p>工厂三兄弟为简单工厂模式、工厂模式、抽象工厂模式</p>\n<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><p>中心思想：</p>\n<p>（1）<strong>面向接口编程</strong></p>\n<p>（2）<strong>把众多的基础类进行抽象</strong>，在创建的时候调用接口来进行创建。</p>\n<p>（3）<strong>没有把工厂进行抽象化</strong></p>\n<p><img src=\"https://q16g-image.oss-cn-beijing.aliyuncs.com/image-20230612173706446.png\" alt=\"image-20230612173706446\"></p>\n<h5 id=\"弊端：\"><a href=\"#弊端：\" class=\"headerlink\" title=\"弊端：\"></a>弊端：</h5><p>（1）违反了开闭原则</p>\n<h3 id=\"工厂模式：\"><a href=\"#工厂模式：\" class=\"headerlink\" title=\"工厂模式：\"></a>工厂模式：</h3><p>简单工厂模式+开闭原则&#x3D;工厂模式</p>\n<p>简单工厂模式是把基层类进行了抽象化，没有把工厂进行抽象化，所以进行开闭原则的基础就是把工厂也进行抽象化，定义一个抽象工厂，然后实现的时候有苹果类的苹果厂、香蕉类的香蕉厂、梨类的梨厂。每个对应的工厂就对应到每个基层类生成中去。</p>\n<h5 id=\"具体实现：\"><a href=\"#具体实现：\" class=\"headerlink\" title=\"具体实现：\"></a>具体实现：</h5><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Fruit <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">Show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">type</span> AbstractFactory <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">CreateFruit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> Fruit\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面定义了两个抽象接口，这里分别是水果接口和梨接口</p>\n<p>下面的苹果、香蕉、梨都实现了这些水果接口</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Apple <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>apple <span class=\"token operator\">*</span>Apple<span class=\"token punctuation\">)</span> <span class=\"token function\">Show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"苹果show\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">type</span> Banana <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>Bn <span class=\"token operator\">*</span>Banana<span class=\"token punctuation\">)</span> <span class=\"token function\">Show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"香蕉show\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">type</span> Pear <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>pear <span class=\"token operator\">*</span>Pear<span class=\"token punctuation\">)</span> <span class=\"token function\">Show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"梨show\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>下面的苹果工厂实现了工厂的接口</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> AppleFactory <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>af <span class=\"token operator\">*</span>AppleFactory<span class=\"token punctuation\">)</span> <span class=\"token function\">CreateFruit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> Fruit <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>Apple<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n","feature":true,"text":"设计模式设计模式主要为提高代码的可读性、提高代码复用程度来进行的。 23种设计模式设计模式的设计理念这里的设计模式设计理念很多，比如开闭原则、单一职责原则、依赖倒转原则、合成复用原则等。这里基于几个重要的原则来进行详细的说明。 开闭原则简单来说就是一个功能点的实现不是靠修改代码来...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":2,"path":"api/tags/开发.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">设计模式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">23种设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5\"><span class=\"toc-text\">设计模式的设计理念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">开闭原则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%90%86%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">开闭原则理解：</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">官方代码实现如下：</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%8A%E7%AB%AF%EF%BC%9A\"><span class=\"toc-text\">官方代码实现的一些弊端：</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%B8%AA%E4%BA%BA%E6%83%B3%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">个人想法：</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%B8%AA%E4%BA%BA%E6%83%B3%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BC%BA%E7%82%B9%E5%92%8C%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5\"><span class=\"toc-text\">个人想法的一些缺点和适用情况</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">依赖倒转原则</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%9A\"><span class=\"toc-text\">合成复用原则：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E7%BB%84%E5%90%88%EF%BC%9A\"><span class=\"toc-text\">详细说明组合：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%8E%82%E4%B8%89%E5%85%84%E5%BC%9Fs\"><span class=\"toc-text\">工厂三兄弟s</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">工厂模式的介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">简单工厂模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%BC%8A%E7%AB%AF%EF%BC%9A\"><span class=\"toc-text\">弊端：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">工厂模式：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">具体实现：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"生产者消费者问题","uid":"35e4bdf3cccf47af2799cbeef79306c1","slug":"生产者消费者问题","date":"2023-06-07T15:11:37.000Z","updated":"2023-06-08T05:17:50.242Z","comments":true,"path":"api/articles/生产者消费者问题.json","keywords":null,"cover":"https://img1.baidu.com/it/u=408399948,2507537664&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=817","text":"什么是生产者消费者问题？（引入） 系统中只有一组生产者和消费者，生产者每次生产一个产品放到缓冲区中，消费者进行每次对缓冲区取一个进程并使用，他们之间的关系就像大学宿舍带饭一样，你把钱给了室友，室友拿着你的钱给你买来了饭。那么传输介质钱就相当于缓冲区。 如果一元为最基本单位，如果你...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":2,"path":"api/tags/开发.json"}],"author":{"name":"Q16G","slug":"blog-author","avatar":"https://www.helloimg.com/images/2023/05/23/oJaeo5.jpg","link":"/","description":"一个潜心学习网络安全的大学生","socials":{"github":"https://github.com/Q16G","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_57222016?spm=1018.2226.3001.5343","juejin":"","customs":{}}},"feature":true}}